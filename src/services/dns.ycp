/**
 * File:	include/network/services/dns.ycp
 * Package:	Network configuration
 * Summary:	Hostname and DNS setup dialog
 * Authors:	Michal Svec <msvec@suse.cz>
 *		Martin Vidner <mvidner@suse.cz>
 *
 * $Id$
 */

{

textdomain "network";

import "CWM";
import "DNS";
import "GetInstArgs";
import "Hostname";
import "IP";
import "Label";
import "Lan";
import "NetworkConfig";
import "Popup";
import "Map";
import "CWMTab";

include "network/routines.ycp";
include "network/widgets.ycp";
include "network/lan/help.ycp";

/**
 * If we know that there are no interfaces with DHCP, we can disable
 * the check boxes.
 * Each dialog must set this variable.
 * HostnameDialog does not know yet whether we will have DHCP so it
 * assumes yes.
 * DNSMainDialog can query Lan::.
 */
boolean has_dhcp = true;

/**
 * If there's a process modifying resolv.conf, we warn the user before
 * letting him change things that will be overwritten anyway.
 * See also #61000.
 */
boolean resolver_modifiable = false;

/**
 * CWM buffer for both dialogs.  Note that NAMESERVERS and SEARCHLIST
 * are lists and their widgets are suffixed.
 */
map hn_settings = $[];

/**
 * @param l list of strings
 * @return only non-empty items
 */
define list<string> NonEmpty (list<string> l) {
    return filter (string s, l, ``(s != ""));
}

/**
 * @return initial settings for this dialog in one map, from DNS::
 */
define map InitSettings () {
 boolean write_hostname = true;

    map settings = $[
	"HOSTNAME": DNS::hostname,
	"DOMAIN": DNS::domain,
	"DHCP_HOSTNAME": NetworkConfig::DHCP["DHCLIENT_SET_HOSTNAME"]:false,
	// set as true by default because there wasn't this option in previous version
	"WRITE_HOSTNAME": NetworkConfig::DHCP["WRITE_HOSTNAME_TO_HOSTS"]:true,
	"DHCP_RESOLV": NetworkConfig::DHCP["DHCLIENT_MODIFY_RESOLV_CONF"]:false,
	];
    // the rest is not so straightforward,
    // because we have list variables but non-list widgets

    /* domain search */
    string searchstring = mergestring (DNS::searchlist, "\n");
    // #49094: populate the search list
    if (searchstring == "" && !settings["DHCP_RESOLV"]:false)
    {
	searchstring = settings["DOMAIN"]:"";
    }
    settings["SEARCHLIST_S"] = searchstring;
    settings["NAMESERVER_1"] = DNS::nameservers[0]:"";
    settings["NAMESERVER_2"] = DNS::nameservers[1]:"";
    settings["NAMESERVER_3"] = DNS::nameservers[2]:"";

    return settings;
}

/**
 * @param settings map of settings to be stored to DNS::
 */
define void StoreSettings (map settings) {
    list<string> nameservers = [
	settings["NAMESERVER_1"]:"",
	settings["NAMESERVER_2"]:"",
	settings["NAMESERVER_3"]:"",
	];
    list<string> searchlist = splitstring (settings["SEARCHLIST_S"]:"",
					   " ,\n\t");

    DNS::hostname = settings["HOSTNAME"]:"";
    DNS::domain = settings["DOMAIN"]:"";
    DNS::nameservers = NonEmpty (nameservers);
    DNS::searchlist = NonEmpty (searchlist);
    NetworkConfig::DHCP["DHCLIENT_SET_HOSTNAME"] = settings["DHCP_HOSTNAME"]:false;
    NetworkConfig::DHCP["WRITE_HOSTNAME_TO_HOSTS"] = settings["WRITE_HOSTNAME"]:true;
    NetworkConfig::DHCP["DHCLIENT_MODIFY_RESOLV_CONF"] = settings["DHCP_RESOLV"]:false;
    /* update modified flag */
    DNS::modified = true;
}

/**
 * Default function to init the value of a widget.
 * Used for push buttons.
 * @param key id of the widget
 */
define void InitHnWidget (string key) {
    any value = hn_settings[key]:nil;
    UI::ChangeWidget (`id (key), `Value, value);
}


/**
 * Default function to store the value of a widget.
 * @param key	id of the widget
 * @param event	the event being handled
 */
define void StoreHnWidget (string key, map event) {
    any value = UI::QueryWidget (`id (key), `Value);
    hn_settings[key] = value;
}

/**
 * Event handler for DHCP_HOSTNAME and WRITE_HOSTNAME checkbox.
 * enable or disable: is DHCP available?
 * @param key	the widget receiving the event
 * @param event	the event being handled
 * @return nil so that the dialog loops on
 */
define symbol HandleDhcpHostname (string key, map event) {
    boolean enabled = has_dhcp;
    UI::ChangeWidget (`id (key), `Enabled, enabled);
    return nil;
}

/**
 * Event handler for DHCP_RESOLV checkbox.
 * enable or disable: is DHCP available and not used now? HUH?!
 * @param key	the widget receiving the event
 * @param event	the event being handled
 * @return nil so that the dialog loops on
 */
define symbol HandleDhcpResolv (string key, map event) {
    boolean enabled = has_dhcp && resolver_modifiable;
    UI::ChangeWidget (`id (key), `Enabled, enabled);
    return nil;
}

/**
 * Event handler for resolver data (nameservers, searchlist)
 * enable or disable: is DHCP available?
 * @param key	the widget receiving the event
 * @param event	the event being handled
 * @return nil so that the dialog loops on
 */
define symbol HandleResolverData (string key, map event) {
    boolean dhcp_resolv = (boolean) UI::QueryWidget (`id ("DHCP_RESOLV"), `Value);
    dhcp_resolv = dhcp_resolv && has_dhcp; // #146162
    boolean enabled = resolver_modifiable && (!dhcp_resolv);
    UI::ChangeWidget (`id (key), `Enabled, enabled);
    return nil;
}

/**
 * Validator for hostname, no_popup
 * @param key	the widget being validated
 * @param event	the event being handled
 * @return whether valid
 */
define boolean ValidateHostname (string key, map event) {
    boolean dhn = has_dhcp && (boolean) UI::QueryWidget (`id ("DHCP_HOSTNAME"), `Value);
    // If the names are set by dhcp, the user may enter backup values
    // here - N#28427. That is, host and domain name are optional then.
    // For static config, they are mandatory.
    string value = (string) UI::QueryWidget (`id (key), `Value);

    if (!dhn || value != "")
    {
	return Hostname::Check (value);
    }
    return true;
}

/**
 * Validator for domain name, no_popup
 * @param key	the widget being validated
 * @param event	the event being handled
 * @return whether valid
 */
define boolean ValidateDomain (string key, map event) {
    boolean dhn = has_dhcp && (boolean) UI::QueryWidget (`id ("DHCP_HOSTNAME"), `Value);
    string value = (string) UI::QueryWidget (`id (key), `Value);

    if (!dhn || value != "")
    {
	return Hostname::CheckDomain (value);
    }
    return true;
}

/**
 * Validator for the search list
 * @param key	the widget being validated
 * @param event	the event being handled
 * @return whether valid
 */
define boolean ValidateSearchList (string key, map event) {
    string value = (string) UI::QueryWidget (`id (key), `Value);
    list<string> sl = NonEmpty (splitstring (value, " ,\n\t"));
    string error = "";

    if (size (sl) > 6)
    {
	/* Popup::Error text */
	error = sformat (_("The search list can have at most %1 domains."), 6);
    }
    else if (size (mergestring (sl, " ")) > 256)
    {
	/* Popup::Error text */
	error = sformat (_("The search list can have at most %1 characters."), 256);
    }
    string bad = find (string s, sl, {
	if (! Hostname::CheckDomain (s)) {
	    /* Popup::Error text */
	    error = sformat (_("The search domain '%1' is invalid."), s) +
	    "\n" + Hostname::ValidDomain ();
	    return true;
	}
	return false;
    });

    if (error != "")
    {
	UI::SetFocus (`id (key));
	Popup::Error (error);
	return false;
    }
    return true;
}


void initModifyResolv (string key){
    string process = DNS::resolv_conf_process;
    if(process == nil || process == "") {
     resolver_modifiable = true;
     UI::ChangeWidget(`id("MODIFY_RESOLV"), `Enabled, false);
    } else {
	 resolver_modifiable = false;
	}
    DNS::resolv_conf_force = resolver_modifiable;
}

symbol handleModifyResolv (string key, map event){
 if ((boolean)UI::QueryWidget(`id("MODIFY_RESOLV"), `Enabled))
  {
   if ((boolean)UI::QueryWidget(`id("MODIFY_RESOLV"), `Value))
    {
     resolver_modifiable = true;
    } else {
	 resolver_modifiable = false;
	}
  }
 return nil;
}


void initHostnameGlobal(string key){
    has_dhcp =  // NetworkService::IsManaged () not: #169858, #156830
	Lan::bootproto == "dhcp" || Lan::AnyDHCPDevice ();

    hn_settings = InitSettings ();
    foreach(string key, (list<string>)Map::Keys(hn_settings),{
     InitHnWidget(key);
    });

 // TODO make checkbox instead of popup
 //    resolver_modifiable = ModifyResolvConfPopup ();
}

map<string, map<string,any> > widget_descr_dns = $[

    "HOSTNAME": $[
	"widget": `textentry,
	/* textentry label */
	"label": Label::HostName (),
	"opt": [],
	"help":
	// help
_("<p>Enter the name for this computer and the DNS domain that it belongs to.</p>"),
	"valid_chars": Hostname::ValidChars,
	"validate_type": `function_no_popup,
	"validate_function": ValidateHostname,
	// validation error popup
	"validate_help": _("The hostname is invalid.") + "\n" + Hostname::ValidHost (),
	],
    "HOSTNAME_GLOBAL": $[
	"widget": `empty,
	// #91202
	"help": help["hostname_global"]:"",
	"init": initHostnameGlobal,
	"store": StoreHnWidget
	],
    "DOMAIN": $[
	"widget": `textentry,
	/* textentry label */
	"label": _("&Domain Name"),
	"opt": [],
	"help": _("<p>The domain is especially important if this computer is a mail server.</p>"),
	// Do nothing (the widget doesnt have notify anyway)
	// In particular do not disable the host and domain name widgets,
	// setting of FQDN should be possible even if DHCP overrides it.
	// N#28427, N#63423.
	// "handle": nil,
	"valid_chars": Hostname::ValidCharsDomain,
	"validate_type": `function_no_popup,
	"validate_function": ValidateDomain,
	// validation error popup
	"validate_help": _("The domain name is invalid.") + "\n" + Hostname::ValidDomain (),
	],
    "DHCP_HOSTNAME": $[
	"widget": `checkbox,
	/* checkbox label */
	"label": _("&Change Hostname via DHCP"),
	"opt": [],
	// help
	"help": help["dhcp_hostname"]:"",
	"handle": HandleDhcpHostname,
	],

    "WRITE_HOSTNAME": $[
	"widget": `checkbox,
	/* checkbox label */
	"label": _("&Write Hostname to /etc/hosts"),
	"opt": [],
	// help
	"help": help["write_hostname"]:"",
	//use the same handler - it enables checkbox if dhcp is used
	"handle": HandleDhcpHostname,
	],
    "MODIFY_RESOLV" : $[
	"widget": `checkbox,
	"label" : _("&Change /etc/resol.conf changed by another process"),
	"opt" : [`notify],
	"init" : initModifyResolv,
	"handle": handleModifyResolv,
	"help" : ""
	],
    "NAMESERVER_1": $[
	"widget": `textentry,
	/* textentry label */
	"label": _("Name Server &1"),
	"opt": [],
	"help": "",		// at "SEARCHLIST_S"
	"handle": HandleResolverData,
	"valid_chars": IP::ValidChars,
	"validate_type": `function_no_popup,
	"validate_function": ValidateIP,
	// validation error popup
	"validate_help": _("The IP address of the name server is invalid.")+ "\n" + IP::Valid4 (),
	],
    // NAMESERVER_2 and NAMESERVER_3 are cloned in the dialog function

    "SEARCHLIST_S": $[
	"widget": `multi_line_edit,
	/* textentry label */
	"label": _("Do&main Search"),
	"opt": [],
	"help": help["searchlist_s"]:"",
	"handle": HandleResolverData,
//	"valid_chars": Hostname::ValidCharsFQ, // TODO: whitespace. unused anyway?
	"validate_type": `function,
	"validate_function": ValidateSearchList,
	],
    "DHCP_RESOLV": $[
	"widget": `checkbox,
	/* checkbox label */
	"label": _("&Update Name Servers and\nSearch List via DHCP"),
	"opt": [`notify],
	// help
	"help": "",		// at "SEARCHLIST_S"
	"handle": HandleDhcpResolv,
	],
    ];

map dns_td = $[
	"resolv" : $[
	 "header" : _("Resolv"),
	 "contents" : `VBox(
	`Frame(	_("Hostname and Domain Name"),
	 `VBox(
	    `HBox(
		"HOSTNAME",
		"HOSTNAME_GLOBAL", // global help, init, store for all dialog
		`HSpacing (1),
		"DOMAIN"
	    ),
	    /* CheckBox label */
	    `Left("DHCP_HOSTNAME"),
	    `Left("WRITE_HOSTNAME")
	)),
	`VSpacing(1),
	`Left("MODIFY_RESOLV"),
	/* Frame label */
	`Frame(_("Name Servers and Domain Search List"), `VBox(
	`VSquash ( `HBox(
	    `HWeight (1, `VBox(
			  "NAMESERVER_1",
			  "NAMESERVER_2",
			  "NAMESERVER_3"
	    )),
	    `HSpacing (1),
	    `HWeight (1, "SEARCHLIST_S")
	)),
	/* CheckBox label */
	`Left ("DHCP_RESOLV")
	)
       ),
       `VStretch()
      ),
	"widget_names" : ["HOSTNAME", "HOSTNAME_GLOBAL", "DOMAIN", "DHCP_HOSTNAME", "WRITE_HOSTNAME", "MODIFY_RESOLV",
				"NAMESERVER_1", "NAMESERVER_2", "NAMESERVER_3", "SEARCHLIST_S", "DHCP_RESOLV"]
	]
];

define boolean ReallyAbortInst () {
    return Popup::ConfirmAbort (`incomplete);
}

define symbol HostnameDialog () {
    has_dhcp = true;

    hn_settings = InitSettings ();

    map functions = $[
	"init" : InitHnWidget,
	"store" : StoreHnWidget,
	`abort : ReallyAbortInst,
    ];
    term contents = `HSquash (
	/* Frame label */
	`Frame(_("Hostname and Domain Name"), `VBox(
	    `HBox(
		"HOSTNAME",
		`HSpacing (1),
		"DOMAIN"
	    ),
	    `Left ("DHCP_HOSTNAME"),
	    `Left ("WRITE_HOSTNAME")
	))
	);

    map<string, map<string,any> > widget_descr = widget_descr_dns;
    symbol ret = CWM::ShowAndRun (
	$[
	    "widget_descr": widget_descr,
	    "contents": contents,
	    // dialog caption
	    "caption": _("Hostname and Domain Name"),
	    "back_button" : Label::BackButton (),
	    "next_button" : Label::NextButton (),
	    "fallback_functions" : functions,
	    "disable_buttons" : GetInstArgs::enable_back() ? [] : ["back_button"],
	]);

    if (ret == `next)
    {
	StoreSettings (hn_settings);
    }

    return ret;
}


define any DNSMainDialog(boolean standalone) {

string caption = _("Network Setting Dialog");
    map widget_descr = $[
        "tab": CWMTab::CreateWidget($[
            "tab_order": ["resolv"],
            "tabs": dns_td,
            "widget_descr": widget_descr_dns,
            "initial_tab" : "resolv",
            "tab_help" : "",
        ]),
    ];
    term contents = `VBox( "tab");

    list<map <string, any> > w = CWM::CreateWidgets (["tab"], (map <string, map <string, any> >)widget_descr);
    string help = CWM::MergeHelps(w);
    contents = CWM::PrepareDialog(contents, w);

    Wizard::SetContentsButtons(caption, contents, help, Label::NextButton (), Label::FinishButton ());
    Wizard::HideBackButton();

    symbol ret = CWM::Run(w, $[`abort:ReallyAbort ]);

    return ret;
}

/* EOF */
}
