/**
 * File:	modules/Lan.ycp
 * Package:	Network configuration
 * Summary:	Network card data
 * Authors:	Michal Svec <msvec@suse.cz>
 *
 * $Id$
 *
 * Representation of the configuration of network cards.
 * Input and output routines.
 */

{

module "Lan";
textdomain "network";

import "Arch";
import "DNS";
import "NetHwDetection";
import "Host";
import "Hostname";
import "IP";
import "Map";
import "Mode";
import "NetworkConfig";
import "NetworkInterfaces";
import "NetworkService";
import "Package";
import "ProductFeatures";
import "Routing";
import "Progress";
import "Service";
import "String";
import "Summary";
import "SuSEFirewall4Network";
import "FileUtils";
import "PackageSystem";
import "LanItems";
import "ModuleLoading";
import "Linuxrc";
import "Stage";
import "LanUdevAuto";
import "Label";

include "network/complex.ycp";
include "network/runtime.ycp";

/*-------------*/
/* GLOBAL DATA */

// gui or cli mode
boolean gui=true;

boolean write_only = false;

/**
 * Current module information
 */
// FIXME: MOD global map Module = $[];

// propose configuration for virtual networks (bridged) ?
global boolean virt_net_proposal = nil;

/**
 * autoinstallation: if true, write_only is disabled and the network settings
 * are applied at once, like during the normal installation. #128810, #168806
 * boolean start_immediately = false;
 */

/**
 * boolean if we do automatic installation in second stage
 */

global boolean automatic_configuration=false;


// ipv6 module
global boolean ipv6=true;

/**
 * Hotplug type ("" if not hot pluggable)
 */

/**
 * Abort function
 * return boolean return true if abort
 */
global block<boolean> AbortFunction = nil;

/**
 * list of interface names which were recently assigned as a slave to a bond device
 */
global list<string> bond_autoconf_slaves = [];


/*--------------*/
/* PRIVATE DATA */



/**
 * Modules information
 * @see ReadModules
 */
// FIXME: MOD map Modules = $[];

/**
 * Deleted modules
 */
// FIXME: MOD list<string> DeletedModules = [];


// FIXME: used in lan/address.ycp (#17346) -> "global"

/*------------------*/
/* GLOBAL FUNCTIONS */
/*------------------*/

/**
 * Return a modification status
 * @return true if data was modified
 */
global boolean Modified() {
    boolean ret  = LanItems::GetModified() || DNS::modified || Routing::Modified() ||
	NetworkConfig::Modified();
    return ret;
}

// function for use from autoinstallation (Fate #301032)
global define boolean isAnyInterfaceDown(){
 boolean down = false;
  map<string, any> link_status = $[];
  list <string> net_devices = splitstring(
	((map<string, any>)SCR::Execute(.target.bash_output, "ls /sys/class/net/ | grep -v lo | tr '\n' ','"))["stdout"]:"", ",") ;
  net_devices = filter(string item, net_devices, {return (size(item)>0);});
  foreach(string net_dev, net_devices, {
   list<string> row = splitstring(((map<string, any>)SCR::Execute(.target.bash_output, sformat("ip address show dev %1 | grep 'inet\\|link' | sed 's/^ \\+//g'|cut -d' ' -f-2", net_dev)))["stdout"]:"", "\n");
    string tmp_mac="";
    boolean addr=false;
    foreach(string column, row, {
     list<string> tmp_col=splitstring(column, " ");
     if (size(tmp_col)<2) continue;
     if (issubstring(tmp_col[0]:"", "link/ether") ) tmp_mac = tmp_col[1]:"";
     if (issubstring(tmp_col[0]:"", "inet") && !issubstring(tmp_col[0]:"", "inet6")) addr = true;
    });
    if (size(tmp_mac)>0) link_status[tmp_mac]=addr;
    y2debug("link_status %1", link_status);
  });

    y2milestone("link_status %1", link_status);
    map <string, any> configurations =  NetworkInterfaces::FilterDevices("");
    foreach(string devtype, splitstring(NetworkInterfaces::CardRegex["netcard"]:"", "|"), {
     foreach(string devname, (list<string>) Map::Keys(configurations[devtype]:$[]), {
//      string confname = NetworkInterfaces::device_name(devtype, devnum);
      string mac = ((map<string, any>)SCR::Execute(.target.bash_output, sformat("cat /sys/class/net/%1/address|tr -d '\n'", devname)))["stdout"]:"";
      y2milestone("confname %1", mac);
      if (!haskey(link_status, mac)) y2error("Mac address %1 not found in map %2!", mac, link_status);
	else if (link_status[mac]:false == false) {
		y2warning("Interface with mac %1 is down!", mac);
		down = true;
	       } else y2debug("Interface with mac %1 is up", mac);
     });
    });
 return down;
}




//include "network/hardware.ycp";
//include "network/install.ycp";
//include "network/routines.ycp";
//include "network/runtime.ycp";

void readIPv6(){
  ipv6=true;

 map<string, map<string, any> > methods = $[
/*
	// this map was created because of too many changes whether ipv6 will be builtin or as a module
        "builtin"  : $[
                "filelist" : ["sysctl.conf"],
                "filepath" : "/etc/",
                "regexp"   : "^[[:space:]]*(net.ipv6.conf.all.disable_ipv6)[[:space:]]*=[[:space:]]*1"
        ],
*/
        "module" : $[
                "filelist" : ["ipv6", "50-ipv6.conf"],
                "filepath" : "/etc/modprobe.d/",
                "regexp"   : "^[[:space:]]*(install ipv6 /bin/true)"
        ]
 ];

 foreach(string which,map<string,any> method, methods, {
 list<string>  filelist = method["filelist"]:[];
 string filepath = method["filepath"]:"";
 string regexp = method["regexp"]:"";

  foreach(string file, filelist,{
    string filename=sformat("%1/%2", filepath, file);
    if (FileUtils::Exists(filename)){
      foreach(string row, splitstring((string)SCR::Read(.target.string, filename), "\n"), {
        if (size(regexptokenize(String::CutBlanks(row), regexp))>0){
           y2milestone("IPv6 is disabled by '%1' method.", which);
           ipv6=false;
        }
      });
    }
  });
 });

}

/**
 * Lan::Read (`cache) will do nothing if initialized already.
 */
boolean initialized = false;
/**
 * Read all network settings from the SCR
 * @param cache:
 *  `cache=use cached data,
 *  `nocache=reread from disk (for reproposal); TODO pass to submodules
 * @return true on success
 */
global define boolean Read (symbol cache) {

    if (cache == `cache && initialized)
    {
	y2milestone ("Using cached data");
	return true;
    }

    /* Read dialog caption */
    string caption = _("Initializing Network Configuration");
    integer steps = 9;

    integer sl = 0; /* 1000; /* TESTING */
    sleep(sl);

    if (gui) Progress::New(caption, " ", steps, [
	/* Progress stage 1/9 */
	_("Detect network devices"),
	/* Progress stage 2/9 */
	_("Read driver information"),
	/* Progress stage 3/9 - multiple devices may be present, really plural*/
	_("Read device configuration"),
	/* Progress stage 4/9 */
	_("Read network configuration"),
	/* Progress stage 5/9 */
	_("Read firewall settings"),
	/* Progress stage 6/9 */
	_("Read hostname and DNS configuration"),
	/* Progress stage 7/9 */
	_("Read installation information"),
	/* Progress stage 8/9 */
	_("Read routing configuration"),
	/* Progress stage 9/9 */
	_("Detect current status"),
    ], [], "");

    if(Abort()) return false;

    // check the environment
//    if(!Confirm::MustBeRoot()) return false;

    if(Abort()) return false;
    /* Progress step 1/9 */
    if (gui) ProgressNextStage(_("Detecting for ndiswrapper..."));
	// modprobe ndiswrapper before hwinfo when needed (#343893)
    if (!Mode::autoinst() && PackageSystem::Installed("ndiswrapper")){
	y2milestone("ndiswrapper: installed");
     if (size((list<string>)SCR::Read(.target.dir, "/etc/ndiswrapper"))>0){
	y2milestone("ndiswrapper: configuration found");
      if ((integer)SCR::Execute(.target.bash, "lsmod |grep -q ndiswrapper")!=0
		&& Popup::YesNo(_("There is a ndiswrapper configuration detected,
but the Kernel module was not modprobed.
Do you want to modprobe ndiswrapper?
"))) {
	if (ModuleLoading::Load("ndiswrapper", "", "", "", false, true)==`fail) Popup::Error(_("ndiswrapper kernel module wasn't loaded.
Check configuration manually."));
	}
     }
    }

    /* ReadHardware(""); /* TESTING */
    sleep(sl);

    if(Abort()) return false;
    /* Progress step 2/9 */
    if (gui) ProgressNextStage(_("Detecting network devices..."));
    // Dont read hardware data in config mode
    if(!Mode::config ()) 
    {
        NetHwDetection::Start();
    }
    // Start interfaces iff running installation. See bnc#395014 and bnc#782283
    if( Mode::installation())
    {
        SetAllLinksUp();
    }
    sleep(sl);

    if(Abort()) return false;
    /* Progress step 3/9 - multiple devices may be present, really plural*/
    if (gui) ProgressNextStage(_("Reading device configuration..."));
     LanItems::Read();
    sleep(sl);

    if(Abort()) return false;
    /* Progress step 4/9 */
    if (gui) ProgressNextStage(_("Reading network configuration..."));
    NetworkConfig::Read();

    readIPv6();

    sleep(sl);

    if(Abort()) return false;
    /* Progress step 5/9 */
    if (gui) ProgressNextStage(_("Reading firewall settings..."));
    boolean orig = Progress::set (false);
    SuSEFirewall4Network::Read ();
    if (gui) Progress::set (orig);
    sleep(sl);

    if(Abort()) return false;
    /* Progress step 6/9 */
    if (gui) ProgressNextStage(_("Reading hostname and DNS configuration..."));
    DNS::Read();
    Host::Read();
    sleep(sl);

    if(Abort()) return false;
    /* Progress step 7/9 */
    if (gui) ProgressNextStage(_("Reading installation information..."));
//    ReadInstallInf();
    sleep(sl);

    if(Abort()) return false;
    /* Progress step 8/9 */
    if (gui) ProgressNextStage(_("Reading routing configuration..."));
    Routing::Read();
    sleep(sl);

    if(Abort()) return false;
    /* Progress step 9/9 */
    if (gui) ProgressNextStage(_("Detecting current status..."));
    NetworkService::Read ();
    sleep(sl);

    if(Abort()) return false;
    /* Final progress step */
    if (gui) ProgressNextStage(_("Finished"));
    sleep(sl);

    if(Abort()) return false;
    LanItems::modified = false;
    initialized = true;

    if (gui) Progress::Finish();

    return true;
}

/**
 * (a specialization used when a parameterless function is needed)
 * @return Read(`cache)
 */
global boolean ReadWithCache () {
    return Read (`cache);
}

global boolean ReadWithCacheNoGUI () {
 gui=false;
 return ReadWithCache();
}

global void SetIPv6(boolean status){
    if(ipv6 != status) {
	 ipv6=status;
	Popup::Warning(_("To apply this change a reboot is needed."));
         LanItems::SetModified();
    }
}

void writeIPv6(){
// uncomment to write to old place (and comment code bellow)
  SCR::Write(.target.string, "/etc/modprobe.d/50-ipv6.conf", sformat("%1install ipv6 /bin/true\n", ipv6?"#":""));
/*
  string filename = "/etc/sysctl.conf";
  string sysctl = (string)SCR::Read(.target.string, filename);
  string sysctl_row = sformat("%1net.ipv6.conf.all.disable_ipv6 = 1", ipv6?"# ":"");
  boolean found = false;
  list<string> file=[];
  foreach(string row, splitstring(sysctl, "\n"), {
    if (size(regexptokenize(row, "(net.ipv6.conf.all.disable_ipv6)"))>0){
         row = sysctl_row;
         found = true;
     }
     file=add(file, row);
  });
  if (!found) file=add(file, sysctl_row);
  SCR::Write(.target.string, filename, mergestring(file, "\n"));
  SCR::Execute(.target.bash, sformat("sysctl -w net.ipv6.conf.all.disable_ipv6=%1",!ipv6?"1":"0"));
*/
  SCR::Write(.sysconfig.windowmanager.KDE_USE_IPV6, ipv6?"yes":"no");
}


/**
 * Update the SCR according to network settings
 * @return true on success
 */
global define boolean Write() {

    y2milestone("Writing configuration");

    // Query modified flag in all components, not just LanItems - DNS,
    // Routing, NetworkConfig too in order not to discard changes made
    // outside LanItems (bnc#439235)
    if(!Modified()) {
	y2milestone("No changes to network setup -> nothing to write");
	return true;
    }

    boolean fw_is_installed = SuSEFirewall4Network::IsInstalled();

    /* Write dialog caption */
    string caption = _("Saving Network Configuration");

    integer sl = 0; /* 1000; /* TESTING */
    sleep(sl);

    list<string> step_labels = [
	/* Progress stage 2 */
	_("Write drivers information"),
	/* Progress stage 3 - multiple devices may be present,really plural*/
	_("Write device configuration"),
	/* Progress stage 4 */
	_("Write network configuration"),
	/* Progress stage 5 */
	_("Write routing configuration"),
	/* Progress stage 6 */
	_("Write hostname and DNS configuration"),
	/* Progress stage 7 */
	_("Set up network services"),
        ];
	/* Progress stage 8 */
     if (fw_is_installed)
        step_labels=add(step_labels, _("Write firewall settings"));
     /* Progress stage 9 */
     if (!write_only) step_labels = add(step_labels, _("Activate network services"));
	/* Progress stage 10 */
     step_labels=add(step_labels, _("Run SuSEconfig"));
     if (!NetworkService::IsManaged() && /*(boolean) SCR::Read(.init.scripts.exists, "smpppd") &&*/ !write_only )
	{
	 /* Progress stage 11 */
	 step_labels=add(step_labels, _("Set up smpppd"));
	}

     Progress::New(caption, " ", size(step_labels), step_labels, [], "");


    if(Abort()) return false;
    /* Progress step 2 */
    ProgressNextStage(_("Writing /etc/modprobe.conf..."));
    sleep(sl);

    if(Abort()) return false;
    /* Progress step 3 - multiple devices may be present, really plural*/
    ProgressNextStage(_("Writing device configuration..."));
    if (LanUdevAuto::AllowUdevModify()) {
	LanItems::WriteUdevDriverRules();
        // wait so that ifcfgs written in NetworkInterfaces are newer
        // (1-second-wise) than netcontrol status files,
        // and rcnetwork reload actually works (bnc#749365)
        SCR::Execute(.target.bash, "udevadm settle");
        sleep(1000);
    }
    // hack: no "netcard" filter as biosdevname names it diferently (bnc#712232)
    NetworkInterfaces::Write("");
    // WriteDevices();
    sleep(sl);

    if(Abort()) return false;
    /* Progress step 4 */
    ProgressNextStage(_("Writing network configuration..."));
    NetworkConfig::Write();
    sleep(sl);

    if(Abort()) return false;
    /* Progress step 5 */
    ProgressNextStage(_("Writing routing configuration..."));
    boolean orig = Progress::set (false);
    Routing::Write();
    sleep(sl);

    if(Abort()) return false;
    /* Progress step 6 */
    ProgressNextStage(_("Writing hostname and DNS configuration..."));
    // write resolv.conf after change from dhcp to static (#327074)
    // reload/restart network before this to put correct resolv.conf from dhcp-backup
    DNS::Write();
    Host::EnsureHostnameResolvable();
    Host::Write();
    Progress::set (orig);

    sleep(sl);

    if(Abort()) return false;
    /* Progress step 7 */
    ProgressNextStage(_("Setting up network services..."));
    NetworkService::EnableDisable ();
    writeIPv6();
    sleep(sl);

    //Show this only if SuSEfirewall is installed
    if(fw_is_installed) {
        if(Abort()) return false;
        /* Progress step 8 */
        ProgressNextStage(_("Writing firewall settings..."));
        orig = Progress::set (false);
        SuSEFirewall4Network::Write ();
        Progress::set (orig);
        sleep(sl);
    }

    if(!write_only) {
	if(Abort())
	    return false;
	/* Progress step 9 */
	ProgressNextStage(_("Activating network services..."));

	// NetworkModules::HwUp ();
	// during installation export sysconfig settings into NetworkManager (bnc#433084)
	if (Mode::installation() && NetworkService::IsManaged())
	    y2internal("Export sysconfig settings into NetworkManager %1", SCR::Execute(.target.bash_output, "/usr/lib/NetworkManager/nm-opensuse-sysconfig-merge --connections"));

	y2internal("virt_net_proposal %1", virt_net_proposal);
	if (Stage::cont() && virt_net_proposal == true && (Linuxrc::usessh() || Linuxrc::vnc() || Linuxrc::display_ip())) {
	    UI::OpenDialog(`opt(`decorated), `HBox(
                `HSpacing(1),
                `HCenter(`HSquash(`VBox(
                    `HCenter(`HSquash(`VBox(
                        // This is the heading of the popup box
                        `Left(`Heading(_("Confirm Network Restart"))),
                        `VSpacing(0.5),
                        // This is in information message. Next come the
                        // hardware class name (network cards).
                        `HVCenter(`Label(_("Because of bridged network YaST2 needs to restart network to apply the settings."))),
                        `VSpacing(0.5)
                    ))),
                    `ButtonBox (
                        `HWeight (1, `PushButton (`id(`ok), `opt(`default, `okButton),  Label::OKButton())),
                        /* PushButton label */
                        `HWeight (1, `PushButton (`id (`cancel), `opt (`cancelButton),  Label::CancelButton()))
                    ),
                    `VSpacing(0.2)
                ))),
                `HSpacing(1)
            ));

	    UI::SetFocus (`id(`ok));

	    // for autoinstallation popup has timeout 10 seconds (#192181)
            // timeout for every case (bnc#429562)
            any ret = UI::TimeoutUserInput(10*1000);
	    if (ret==`ok){
		y2internal("Restarting network because of bridged proposal");
		Service::Restart("network");
	    }
	    UI::CloseDialog();
        }

        // For ssh/vnc installation don't reload/restart network because possibility of IP change (bnc#347482)
        else if (Stage::cont() && (Linuxrc::usessh() || Linuxrc::vnc() || Linuxrc::display_ip())) 
            y2milestone("For ssh or vnc installation don't reload/restart network during installation.");
        else if (LanItems::force_restart)
            Service::Restart("network");
        else if(Service::Status("network")==0){
            Service::Reload("network");
        }
        else Service::Restart("network");
//          NetworkService::StartStop ();
        sleep(sl);
    }

    if(Abort()) return false;
    /* Progress step 10 */
    ProgressNextStage(_("Running SuSEconfig..."));
    if(!write_only) 
	RunSuSEconfig();
    sleep(sl);

    if (!NetworkService::IsManaged() /*&& (boolean) SCR::Read(.init.scripts.exists, "smpppd")*/ && !write_only )
    {
       if(Abort()) return false;
       /* Progress step 11 */
       ProgressNextStage(_("Setting up smpppd(8)..."));
       // takes care of autoinst by itself
       SetupSMPPPD(false);
       sleep(sl);
    }

    // can't there just be 'else' instead of 'if'? fB.
    if (NetworkService::IsManaged())
    {
	boolean network=false;
	integer timeout=15;
	while(timeout>0)
	{
	  if (NetworkService::isNetworkRunning()){
	   network=true;
	   break;
	  }
	  y2milestone("waiting for network ... %1", timeout);
	  sleep(1000);
	  timeout = timeout-1;
	}
	if (!network) 
	    y2error("No network running");
    }

    /* Final progress step */
    ProgressNextStage(_("Finished"));
    sleep(sl);

    Progress::Finish();

    if(Abort()) return false;
    return true;
}

/**
 * Only write configuration without starting any init scripts and SuSEconfig
 * @return true on success
 */
global define boolean WriteOnly() {
    write_only = !LanItems::autoinstall_settings["start_immediately"]:false;
    return Write();
}

/**
 * Import data
 * @param settings settings to be imported
 * @return true on success
 */
global define boolean Import(map settings) {

        NetworkInterfaces::Import("netcard", (map<string, map>) settings["devices"]:$[]);
	foreach(string device, NetworkInterfaces::List(""), {
	LanItems::AddNew();
	LanItems::Items[LanItems::current]=$["ifcfg":device];
	});

    LanItems::autoinstall_settings["start_immediately"] = settings["start_immediately"]:false;
    LanItems::autoinstall_settings["strict_IP_check_timeout"] = settings["strict_IP_check_timeout"]:-1;

    NetworkConfig::Import(settings["config"]:$[]);
    DNS::Import((map) eval(settings["dns"]:$[]));
    Routing::Import((map) eval(settings["routing"]:$[]));
    NetworkService::SetManaged (settings["managed"]:false);

    LanItems::modified = true;
    return true;
}

/**
 * Export data
 * @return dumped settings (later acceptable by Import())
 */
global define map Export() {
 map devices = NetworkInterfaces::Export("");
 map udev_rules = LanUdevAuto::Export(devices);
    return $[
	"dns"		: DNS::Export(),
	// FIXME: MOD "modules"	: Modules,
	"s390-devices"  : udev_rules["s390-devices"]:$[],
	"net-udev"  	: udev_rules["net-udev"]:$[],
	"config"	: NetworkConfig::Export(),
	"devices"	: devices,
	"routing"	: Routing::Export(),
	"managed"	: NetworkService::IsManaged (),
	"start_immediately": LanItems::autoinstall_settings["start_immediately"]:false, //start_immediately,
    ];
}

/**
 * Create a textual summary and a list of unconfigured devices
 * @param mode "split": split configured and unconfigured?<br />
 *             "summary": add resolver and routing symmary,
 *		"proposal": for proposal, add links for direct config
 * @return summary of the current configuration
 */
global define list Summary(string mode) {

    boolean split = (mode == "split");

    list sum = LanItems::BuildLanOverview();

    /* Testing improved summary */
    if(mode == "summary")
	sum[0] = sum[0]:"" + DNS::Summary() + Routing::Summary();

    return sum;
}

/**
 * Create a textual summary for the general network settings 
 * proposal (NetworkManager + ipv6)
 * @return [rich text, links]
 */
global define list SummaryGeneral () {
    string status_nm = nil;
    string status_v6 = nil;
    string status_virt_net = nil;
    string href_nm = nil;
    string href_v6 = nil;
    string href_virt_net = nil;
    string link_nm = nil;
    string link_v6 = nil;
    string link_virt_net = nil;
    string header_nm = _("Network Mode");

    if (NetworkService::IsManaged ())
    {
	href_nm = "lan--nm-disable";
	// network mode: the interfaces are controlled by the user
	status_nm = _("Interfaces controlled by NetworkManager");
	// disable NetworkManager applet
	link_nm = Hyperlink (href_nm, _("Disable NetworkManager"));
    }
    else
    {
	href_nm = "lan--nm-enable";
	// network mode
	status_nm = _("Traditional network setup with NetControl - ifup");
	// enable NetworkManager applet
	// for virtual network proposal (bridged) don't show hyperlink to enable networkmanager
	link_nm = (virt_net_proposal) ? "..." : Hyperlink (href_nm, _("Enable NetworkManager"));
    }

    if (ipv6)
    {
	href_v6 = "ipv6-disable";
	// ipv6 support is enabled
	status_v6 = _("Support for IPv6 protocol is enabled");
	// disable ipv6 support
	link_v6 = Hyperlink (href_v6, _("Disable IPv6"));
    }
    else
    {
	href_v6 = "ipv6-enable";
	// ipv6 support is disabled
	status_v6 = _("Support for IPv6 protocol is disabled");
	// enable ipv6 support
	link_v6 = Hyperlink (href_v6, _("Enable IPv6"));
    }
   // no exception needed for virtualbox* (bnc#648044) http://www.virtualbox.org/manual/ch06.html
   if ( (PackageSystem::Installed("xen") && !Arch::is_xenU()) || PackageSystem::Installed("kvm")||
         PackageSystem::Installed("qemu")
    ){
    if (virt_net_proposal){
	href_virt_net = "virtual-revert";
	status_virt_net = _("Proposed bridged configuration for virtual machine network");
	link_virt_net = Hyperlink(href_virt_net, _("Use non-bridged configuration"));
    } else {
        href_virt_net = "virtual-enable";
        status_virt_net = _("Proposed non-bridged network configuration");
        link_virt_net = Hyperlink(href_virt_net, _("Use bridged configuration"));
    }
   }
    string descr = sformat ("<ul><li>%1: %2 (%3)</li></ul> 
			     <ul><li>%4 (%5)</li></ul>", header_nm, status_nm, link_nm,
			     status_v6, link_v6);
    if (link_virt_net!=nil) descr=sformat("%1
						<ul><li>%2 (%3)</li></ul>", descr, status_virt_net, link_virt_net);
    list<string> links = [ href_nm, href_v6 ];
    if (href_virt_net!=nil) links = add (links, href_virt_net);
    return [descr, links];
}




/**
 * Add a new device
 * @return true if success
 */
global define boolean Add() {
//    LanItems::operation = nil;
    if(LanItems::Select("") != true) return false;
    NetworkInterfaces::Add();
//    LanItems::AddNew();
    return true;
}

/**
 * Edit the given device
 * @param name device to edit
 * @return true if success
 */
global define boolean Edit(string name) {
    LanItems::operation = nil;
    if(LanItems::Select(name) != true) return false;
    NetworkInterfaces::Edit(name);
    LanItems::operation = `edit;
    LanItems::interfacename = NetworkInterfaces::Name;
    return true;
}
/**
 * Delete the given device
 * @param name device to delete
 * @return true if success
 */
global define boolean Delete() {
 LanItems::DeleteItem();
/*
    operation = nil;
    if(Select(name) != true) return false;
    NetworkInterfaces::Delete(name);
    operation = `delete;
*/
    return true;
}


/**
 * Uses product info and is subject to installed packages.
 * @return Should NM be enabled?
 */ 
define boolean UseNetworkManager () {
    boolean nm_default = false;
    string nm_feature = ProductFeatures::GetStringFeature ("network", "network_manager");
    if (nm_feature == "")
    {
	// compatibility: use the boolean feature
	// (defaults to false)
	nm_default = ProductFeatures::GetBooleanFeature ("network", "network_manager_is_default");
    }
    else if (nm_feature == "always")
    {
	nm_default = true;
    }
    else if (nm_feature == "laptop")
    {
	nm_default = Arch::is_laptop ();
	y2milestone ("Is a laptop: %1", nm_default);
    }
    else // nm_feature == "never"
    {
	nm_default = false;
    }

    boolean nm_installed = Package::Installed ("NetworkManager");
    y2milestone ("NetworkManager wanted: %1, installed: %2", nm_default, nm_installed);
    return nm_default && nm_installed;
}

/**
 * Create minimal ifcfgs for the case when NetworkManager is used:
 * NM does not need them but yast2-firewall and SuSEfirewall2 do
 * Avoid existing ifcfg from network installation
 */
define void ProposeNMInterfaces () {
    y2milestone ("Minimal ifcfgs for NM");
    foreach (integer number, any lanitem, LanItems::Items, {
	if (hasAnyValue(((map)lanitem)["hwinfo", "dev_name"]:"")) {
	LanItems::current = number;
	if (!LanItems::IsItemConfigured()){
	  y2milestone("Nothing already configured start proposing %1 (NM)", LanItems::getCurrentItem());
	  LanItems::ProposeItem();
	 }
	}
    });

}

list<string> IfcfgsToSkipVirtualizedProposal() {
    list<string> skipped = [];
    foreach(integer current, any config, LanItems::Items, {
            string ifcfg = LanItems::Items[current, "ifcfg"]:"";
            if (NetworkInterfaces::GetType(ifcfg)=="br"){
                NetworkInterfaces::Edit(ifcfg);
                y2milestone("Bridge %1 with ports (%2) found", ifcfg, NetworkInterfaces::Current["BRIDGE_PORTS"]:"");
                skipped=add(skipped, ifcfg);
                foreach(string port, (list<string>) splitstring(NetworkInterfaces::Current["BRIDGE_PORTS"]:"", " "), {
                        skipped=add(skipped, port);
                    });
            }
            if (NetworkInterfaces::GetType(ifcfg)=="bond")
            {
                NetworkInterfaces::Edit(ifcfg);

                foreach( string slave, LanItems::GetBondSlaves( ifcfg), 
                {
                        y2milestone("For interface %1 found slave %2", ifcfg, slave);
                        skipped=add(skipped, slave);
                });
            }
	     // Skip also usb device as it is not good for bridge proposal (bnc#710098)
            if (NetworkInterfaces::GetType(ifcfg)=="usb"){
                NetworkInterfaces::Edit(ifcfg);
                y2milestone("Usb device %1 skipped from bridge proposal", ifcfg);
                skipped=add(skipped, ifcfg);
	    }
            if (NetworkInterfaces::GetValue(ifcfg, "STARTMODE")=="nfsroot"){
                y2milestone("Skipped %1 interface from bridge slaves because of nfsroot.", ifcfg);
                skipped=add(skipped, ifcfg);
            }
        });
    y2milestone("Skipped interfaces : %1", skipped);
    return skipped;
}

void ProposeVirtualized() {
    // in case of virtualization use special proposal
    // collect all interfaces that will be skipped from bridged proposal
    list<string> skipped = IfcfgsToSkipVirtualizedProposal();

    // first configure all connected unconfigured devices with dhcp (with default parameters)
    foreach (integer number, any lanitem, LanItems::Items, {
            if (hasAnyValue(((map)lanitem)["hwinfo", "dev_name"]:"")) {
                LanItems::current = number;
                boolean link = LanItems::getCurrentItem()["hwinfo", "link"]:false == true;
                if (!link) y2warning("item number %1 has link:false detected", number);
                if (!LanItems::IsItemConfigured() && link && !contains(skipped, LanItems::getCurrentItem()["hwinfo", "dev_name"]:"")){
                    y2milestone("Nothing already configured - start proposing");
                    LanItems::ProposeItem();
                }
            }
        });

    // then each configuration (except bridges) move to the bridge
    // and add old device name into bridge_ports
    foreach(integer current, any config, LanItems::Items, {
            string ifcfg = LanItems::Items[current, "ifcfg"]:"";
            if (contains(skipped, ifcfg)){
                y2milestone("Skipping interface %1", ifcfg);
                continue;
            }
            else if (size(ifcfg)>0){
                NetworkInterfaces::Edit(ifcfg);
                map<string, any> old_config = NetworkInterfaces::Current;
                y2debug("Old Config %1\n%2", ifcfg, old_config);
                string new_ifcfg = sformat("br%1", NetworkInterfaces::GetFreeDevice("br"));
                y2milestone("old configuration %1, bridge %2", ifcfg, new_ifcfg);
                NetworkInterfaces::Name = new_ifcfg;
                // from bridge interface remove all bonding-related stuff
                foreach(string key, any value, NetworkInterfaces::Current, {
                        if (issubstring(key, "BONDING")){
                            NetworkInterfaces::Current[key]=nil;
                        }
                    });
                NetworkInterfaces::Current["BRIDGE"]="yes";
                NetworkInterfaces::Current["BRIDGE_PORTS"]=ifcfg;
                NetworkInterfaces::Current["BRIDGE_STP"]="off";
                NetworkInterfaces::Current["BRIDGE_FORWARDDELAY"]="0";
                // hardcode startmode (bnc#450670), it can't be ifplugd!
                NetworkInterfaces::Current["STARTMODE"]="onboot";
                // remove description - will be replaced by new (real) one
                NetworkInterfaces::Current=remove(NetworkInterfaces::Current, "NAME");
                // remove ETHTOOLS_OPTIONS as it is useful only for real hardware
                NetworkInterfaces::Current=remove(NetworkInterfaces::Current, "ETHTOOLS_OPTIONS");
                if( NetworkInterfaces::Commit() ){
                    NetworkInterfaces::Add();
                    NetworkInterfaces::Edit(ifcfg);
                    old_config["BOOTPROTO"]="static";
                    old_config["IPADDR"]="0.0.0.0/32";
                    // remove all aliases (bnc#590167)
                    foreach (string a, any v, (map <string, any>)NetworkInterfaces::Current["_aliases"]:$[], {
                            if (v != nil) { NetworkInterfaces::DeleteAlias (NetworkInterfaces::Name, a); }
                        });
                    //take out PREFIXLEN from old configuration (BNC#735109)
                    old_config["PREFIXLEN"]="";
                    old_config["_aliases"]=$[];
                    y2milestone("Old Config with apllied changes %1\n%2", ifcfg, old_config);
                    NetworkInterfaces::Current = old_config;
                    NetworkInterfaces::Commit();

                    LanItems::Items[current, "ifcfg"] = new_ifcfg;
                    LanItems::modified=true;
                    LanItems::force_restart=true;
                    y2internal("List %1", NetworkInterfaces::List(""));
                    // re-read configuration to see new items in UI
                    LanItems::Read();
                }
            }
            else y2warning("empty ifcfg");
        });
}

/**
 * Propose interface configuration
 * @return true if something was proposed
 */
global define boolean ProposeInterfaces () {
    y2milestone("Hardware=%1", LanItems::Hardware);

    y2milestone("NetworkConfig::Config=%1", NetworkConfig::Config);
    y2milestone("NetworkConfig::DHCP=%1", NetworkConfig::DHCP);

    // test if we have any virtualization installed
    if (virt_net_proposal) {
        y2milestone("Virtualization [xen|kvm|qemu] detected - will propose virtualization network");
        ProposeVirtualized();
    }
    else {

        if (! LanItems::nm_proposal_valid) {
            NetworkService::SetManaged (UseNetworkManager ());
            LanItems::nm_proposal_valid = true;
        }

        if (NetworkService::IsManaged ()) {
            ProposeNMInterfaces ();

            LanItems::modified = true;	// #144139 workaround
            y2milestone ("NM proposal");
            return true;
        }

    }
    /* Something is already configured -> do nothing */
    boolean configured=false;
    foreach (integer number, any lanitem, LanItems::Items, {
            LanItems::current = number;
            if (LanItems::IsItemConfigured()){
                y2milestone("Something already configured: don't propose.");
                configured = true;
                break;
            }
        });
    if (configured) return false;


    foreach (integer number, any lanitem, LanItems::Items, {
            if (hasAnyValue(((map)lanitem)["hwinfo", "dev_name"]:"")) {
                LanItems::current = number;
                boolean link = LanItems::getCurrentItem()["hwinfo", "link"]:false;
                if (LanItems::getCurrentItem()["hwinfo", "type"]:"" == "wlan")
                    y2warning("Will not propose wlan interfaces");
                else{
                    if (!link) y2warning("item number %1 has link:false detected", number);
                    else if (!LanItems::IsItemConfigured() && link){
                        y2milestone("Nothing already configured - start proposing");
                        LanItems::ProposeItem();
                        break;
                    }
                }
            }
        });

    y2milestone("NetworkConfig::Config=%1", NetworkConfig::Config);
    y2milestone("NetworkConfig::DHCP=%1", NetworkConfig::DHCP);

    return true;
}

/**
 * Propose the hostname
 * See also DNS::Read
 * @return true if something was proposed
 */
define boolean ProposeHostname () {
    if (DNS::proposal_valid)
    {
	// the standalone hostname dialog did the job already
	return false;
    }

/*
    y2milestone ("hostname from install.inf");
    if (! DNS::ReadHostDomain (InstallInf["hostname"]:"",
			       InstallInf["domain"]:""))
    {
	y2milestone ("hostname from dns");
	// try to get hostname from the network 
	string hnent = NetHwDetection::ResolveIP(ipaddr);

        //last resort - generate random hostname (#165269)
        if (hnent == "")
        {
            y2milestone("random hostname");
            srandom ();
            DNS::ReadHostDomain("linux-" + String::Random(4), "site");
        }
        else
        {
            list hnsplit = Hostname::SplitFQ(hnent);
            DNS::ReadHostDomain (hnsplit[0]:"", hnsplit[1]:"");
        }

    }
*/
    return true;    
}

/**
 * Propose configuration for routing and resolver
 * @return true if something was proposed
 */
global define boolean ProposeRoutesAndResolver () {
    if(LanItems::bootproto == "static" && LanItems::ipaddr != "" && LanItems::ipaddr != nil) {
	/* propose default gateway from /etc/install.inf */
//	Routing::ReadFromGateway (InstallInf["gateway"]:"");

	/* propose DNS setup from /etc/install.inf */
//	DNS::ReadNameserver (InstallInf["nameserver"]:"");
	ProposeHostname ();
    }
    return true;
}

/**
 * Propose a configuration
 * @return true if something was proposed
 */
global define boolean Propose() {
NetworkInterfaces::CleanCacheRead();
LanItems::Read();
    return
	ProposeInterfaces () &&
	ProposeRoutesAndResolver ();
}

/**
 * Create a configuration for autoyast
 * @return true if something was proposed
 */
global define boolean Autoinstall() {

    y2milestone("Hardware=%1", LanItems::Hardware);
    map tosel = nil;

    /* Some HW found -> use it for proposal */
    if(size(LanItems::Hardware) > 0
       && size(LanItems::autoinstall_settings["interfaces"]:[]) > 0) {

        foreach(map<string, string> interface, LanItems::autoinstall_settings["interfaces"]:[], ``{
                
            list<string> devs = NetworkInterfaces::List("");
            y2milestone("devs: %1", devs);
            tosel = nil;

            Add();

    	    tosel = LanItems::FindMatchingDevice(interface);

	    y2milestone("tosel=%1", tosel);

            // Read module data from autoyast
            map aymodule = LanItems::GetModuleForInterface(interface["device"]:"",
                LanItems::autoinstall_settings["modules"]:[]);


	    if (tosel != nil)
	    {
		tosel["module"] = (aymodule["module"]:""!= "")?
		    aymodule["module"]:"" : tosel["module"]:"";
		tosel["options"] = (aymodule["options"]:""!= "")?
		    aymodule["options"]:"" : tosel["options"]:"";
		
		LanItems::SelectHWMap(tosel);
	    }
	    /* Nothing detected -> use InstallInf */
/*
	    else if(size(InstallInf) > 0) {

		if(!haskey(InstallInf, "module")) {
		    y2milestone("No hardware, no install.inf module -> no proposal.");
		    return false;
		}
		NetworkModules::Alias = InstallInf["module"]:"";
		NetworkModules::Options = InstallInf["options"]:"";

//		type = InstallInf["type"]:"eth";
		device = NetworkInterfaces::GetFreeDevice(type);
	    }
*/
	    else {
		y2milestone("No hardware, no install.inf -> no autoinstallation possible.");
		return false;
	    }

	    // The uppercasing is also done in lan_auto::FromAY
	    // but the output goes to "devices" whereas here
	    // we use "interfaces". FIXME.
            string newk = nil;
            interface =  mapmap(string k, string v, interface, ``{
                    newk = toupper(k);
                    return $[newk: v];
                    });


	    map defaults = union (LanItems::SysconfigDefaults, LanItems::GetDefaultsForHW ());

            // Set interface variables
	    LanItems::SetDeviceVars(interface, defaults);

	    y2debug("ipaddr,bootproto=%1,%2", LanItems::ipaddr, LanItems::bootproto);
            if(LanItems::bootproto == "static" && LanItems::ipaddr != "" && LanItems::ipaddr != nil) 
            {

                y2milestone("static configuration");

		if(LanItems::netmask == nil || LanItems::netmask == "")
		    LanItems::netmask = "255.255.255.0";
	
	    }
	    LanItems::Commit();
	});
    }
    else 
    {
        y2milestone ("no interface configuration, taking it from install.inf");
        ProposeInterfaces ();
    }

    // #153426 - using ProposeInterfaces instead of Propose omitted these
    // if they are nonempty, Import has already taken care of them.
    if (LanItems::autoinstall_settings["routing", "routes"]:[] == [])
    {
	y2milestone ("gateway from install.inf");
//	Routing::ReadFromGateway (InstallInf["gateway"]:"");
    }
    if (LanItems::autoinstall_settings["dns", "nameservers"]:[] == [])
    {
	y2milestone ("nameserver from install.inf");
//	DNS::ReadNameserver (InstallInf["nameserver"]:"");
    }
    if (LanItems::autoinstall_settings["dns", "hostname"]:"" == "")
    {
	ProposeHostname ();
    }

    return true;
}


/**
 * Check if any device  is configured with DHCP.
 * @return true if any DHCP device is configured
 */
global define boolean AnyDHCPDevice() {
 // return true if there is at least one device with dhcp4, dhcp6, dhcp or dhcp+autoip
   return size(
	  union(
	    union(
	     NetworkInterfaces::Locate("BOOTPROTO", "dhcp4"),
	     NetworkInterfaces::Locate("BOOTPROTO", "dhcp6")
		 ),
	   union(
	     NetworkInterfaces::Locate("BOOTPROTO", "dhcp"),
	     NetworkInterfaces::Locate("BOOTPROTO", "dhcp+autoip")
		)
	       )
	      ) > 0;
}


global define list<map> PrepareForAutoinst() {
  
//    ReadInstallInf();     
    LanItems::ReadHw();
    return LanItems::Hardware;
}

/**
 * @return list of packages needed when writing the config
 */
global list<string> Packages () {
    list<string> pkgs = [];
 // #299033 - don't install smpppd now, do it later (with some tests)
/*
    if (NetworkInterfaces::Locate ("USERCONTROL", "yes") != [])
    {
	if (!PackageSystem::Installed("smpppd")) pkgs = add (pkgs, "smpppd");
    }
*/
   map<string, any> required = $[
			"types":$[
				"wlan" : "wireless-tools",
				"vlan" : "vlan",
				"br"   : "bridge-utils",
				"tun"  : "tunctl",
				"tap"  : "tunctl"
			],
			"options":$[
				"STARTMODE":$[
					"ifplugd" : "ifplugd"
				],
				"WIRELESS_AUTH_MODE":$[
					"psk" : "wpa_supplicant",
					"eap" : "wpa_supplicant"
				]
			]
		];

    foreach(string type, (list<string>)Map::Keys(required["types"]:$[]), {
     string package=required["types", type]:"";
     if (size( NetworkInterfaces::List(type) ) > 0) {
	y2milestone("Network interface type %1 requires package %2", type, package);
	if (!PackageSystem::Installed( package )) pkgs = add (pkgs, package);
    }
    });


    foreach(string type, (list<string>)Map::Keys(required["options"]:$[]), {
     foreach(string option, (list<string>)Map::Keys(required["options", type]:$[]), {
      string package=required["options", type, option]:"";
      if (NetworkInterfaces::Locate (type, option) != []){
       y2milestone("Network interface with options %1, %2 requires package %3", type, option, package);
       if (!PackageSystem::Installed(package)) pkgs = add (pkgs, package);
      }
     });
    });

    if (NetworkService::IsManaged ())
    {
	if (!PackageSystem::Installed("NetworkManager")) pkgs = add (pkgs, "NetworkManager");
    }
    return pkgs;
}

/**
 * @return list of packages needed when writing the config in autoinst
 * mode
 */
global map AutoPackages () {
      return ($["install": Packages(), "remove": []]);
}

/**
 * Xen bridging confuses us (#178848)
 * @return whether xenbr* exists
 */
global define boolean HaveXenBridge () {
    //adapted test for xen bridged network (bnc#553794)
    boolean have_br = FileUtils::Exists("/dev/.sysconfig/network/xenbridges");
    // #2248874 - disallow error message
/*
    if (PackageSystem::Installed("bridge-utils")){
     string cmd = "brctl show | grep '^xenbr'";
     have_br = SCR::Execute (.target.bash, cmd) == 0;
    }
*/
    y2milestone ("Have Xen bridge: %1", have_br);
    return have_br;
}

/* EOF */
}
