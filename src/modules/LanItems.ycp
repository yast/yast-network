{

module "LanItems";
textdomain "network";

import "NetworkDevices";
import "ProductFeatures";
import "NetworkConfig";
import "NetworkStorage";
include "network/complex.ycp";
include "network/routines.ycp";

/**
 * Hardware information
 * @see ReadHardware
 */
global map<integer, any> Items = $[];
global list<map> Hardware = [];
global map <string, any> udev_rules = $[];

global string interfacename="";

// used at autoinstallation time
global map autoinstall_settings = $[];

/**
 * Data was modified?
 */
global boolean modified = false;
/* current selected HW */
map hw = $[];

/**
 * Which operation is pending?
 */
global symbol operation = nil;



global string description = "";
global string unique = "";

global string type = "";
global string device = "";
global string alias = "";
global integer current = -1;
global string hotplug = "";

global list<string> Requires = [];

/* address options */
/** boot protocol: BOOTPROTO */
global string bootproto = "static";
global string ipaddr = "";
global string remoteip = "";
global string netmask = "";

global string startmode = "auto";
global boolean usercontrol = false;
global string mtu = "";
global string ethtool_options = "";

/* wireless options */
global string wl_mode = "";
global string wl_essid = "";
global string wl_nwid = "";
global string wl_auth_mode = "";
// when adding another key, don't forget the chmod 600 in NetworkDevices
global string wl_wpa_psk = "";
global string wl_key_length = "";
global list<string> wl_key = [];
global integer wl_default_key = 0;
global string wl_nick = "";

//bond options
global list<string> bond_slaves = [];
global string bond_option="";
/**
 * wl_wpa_eap aggregates the settings in a map for easier CWM access.
 * @struct wpa_eap
 * WPA_EAP_MODE: string ("TTLS" "PEAP" or "TLS")
 * WPA_EAP_IDENTITY: string
 * WPA_EAP_PASSWORD: string (for TTLS and PEAP)
 * WPA_EAP_ANONID: string (for TTLS and PEAP)
 * WPA_EAP_CLIENT_CERT: string (for TLS, file name)
 * WPA_EAP_CLIENT_KEY: string (for TLS, file name)
 * WPA_EAP_CLIENT_KEY_PASSWORD: string (for TLS)
 * WPA_EAP_CA_CERT: string (file name)
 * WPA_EAP_AUTH: string ("", "MD5", "GTC", "CHAP"*, "PAP"*, "MSCHAP"*, "MSCHAPV2") (*: TTLS only)
 * WPA_EAP_PEAP_VERSION: string ("", "0", "1")
 */
global map<string, any> wl_wpa_eap = $[];
global string wl_channel = "";
global string wl_frequency = "";
global string wl_bitrate = "";
global string wl_accesspoint = "";
global boolean wl_power = true;

// Card Features from hwinfo
// if not provided, we use the default full list
global list<string> wl_auth_modes = nil;
global list<string> wl_enc_modes = nil;
global list<string> wl_channels = nil;
global list<string> wl_bitrates = nil;
list<string> nilliststring = nil; // to save some casting

/* s390 options */
// portname is in ifcfg, others are in hwcfg
global string portname = "";
global string chan_mode = "0";
global string qeth_options = "";
global boolean ipa_takeover = false;
// #84148
// 26bdd00.pdf
// Ch 7: qeth device driver for OSA-Express (QDIO) and HiperSockets
// MAC address handling for IPv4 with the layer2 option
global boolean qeth_layer2 = false;
global string qeth_macaddress = "00:00:00:00:00:00";
// Timeout for LCS LANCMD
global string lcs_timeout = "5";

/* aliases */
global map aliases = $[];

/* propose options */
global boolean proposal_valid = false;
global boolean nm_proposal_valid = false;

/* NetworkModules:: name */
global string nm_name = "";
global string nm_name_old = nil;

include "network/hardware.ycp";

map <string, any> ReadUdevRules(){
 udev_rules = (map<string, any>)SCR::Read(.udev_persistent);
 return udev_rules;
}

void WriteUdevRules(){
  SCR::Write(.udev_persistent, udev_rules);
}

/**
 * Data was modified?
 * @return true if modified
 */
global define boolean Modified() {
    y2debug("modified=%1",modified);
    return modified;
}

/**
 * Function which returns if the settings were modified
 * @return boolean  settings were modified
 */
global define boolean GetModified () {
    return modified;
}
/**
 * Function sets internal variable, which indicates, that any
 * settings were modified, to "true"
 */
global define void SetModified () {
    modified = true;
}
/**
 * Function sets internal variable, which indicates, that any
 * settings were modified, to "false"
 */
global define void UnsetModified () {
    modified = false;
}


/*
 * return list of available modules for current device
 * with default default_module (on first possition)
 */

global list<string> GetItemModules(string default_module){
 list<string> mods = [];
 if (hasAnyValue(default_module)) mods = add(mods, default_module);
  foreach(map row, Items[current, "hwinfo", "drivers"]:[], {
   string tmp_mod = row["modules", 0, 0]:"";
   if (!contains(mods, tmp_mod)) mods = add(mods, tmp_mod);
 });
 return mods;
}

global void ReadHw(){
 Hardware = ReadHardware("netcard");
 ReadUdevRules();
 foreach(map hwitem, Hardware, {
  list udev = (hwitem["dev_name"]:"" != "") ? udev_rules[hwitem["dev_name"]:""]:[] : [];
  Items[size(Items)] = $["hwinfo":hwitem, "udev":udev];
 });
}

global void ReadNetworkModules(){
 NetworkModules::Read();
y2internal("NetworkModules::ListM  %1", NetworkModules::ListM(""));
}

global void ReadNetworkInterfaces(){
    NetworkDevices::Read();
    NetworkDevices::CleanHotplugSymlink();
    foreach(string tmpdevname, (list<string>)Map::Keys(NetworkDevices::FilterDevices("netcard")["eth"]:$[]), {
     string confname = NetworkDevices::device_name("eth", tmpdevname);

//     map config = getcfg(confname, "");
     integer pos = nil;
     map<string, any> val = $[];
     foreach(integer key, map<string, any> value, (map<integer, map<string, any> >)Items, {
//	 if (config["HWD_DEVICEPATH"]:"" == sformat("/sys%1", value["hwinfo", "sysfs_id"]:"")) {
	if (value["hwinfo", "dev_name"]:""==confname) {
		pos = key;
		val = value;
	 }
	});
	if (pos == nil) {
		pos=size(Items);
		Items[pos]=$[];
		}
//	Items[pos, "hwcfg"] = val[sformat("HWD_INTERFACE_%1", tointeger(val["HWD_INTERFACE_N"]:"0")-1)]:"";
	Items[pos, "ifcfg"] = confname;
    });
 y2milestone("LanItems::Items %1", Items);
}

list GetDescr(){
 list descr = [];
 foreach(integer key, map<string, any> value, (map<integer, map<string, any> >)Items, {

  if ( haskey(value, "table_descr") && size(Items[key, "table_descr"]:$[])>1)
	descr = add(descr, $["id":key,
				"rich_descr":Items[key, "table_descr", "rich_descr"]:"",
				"table_descr":Items[key, "table_descr", "table_descr"]:[]
				]);
	});
 return descr;
}

global list BuildLanOverview() {
    list<string> overview=[];
    list<string> links=[];
    map startmode_descrs = $[
	// summary description of STARTMODE=auto
	"auto": _("Started automatically at boot"),
	// summary description of STARTMODE=hotplug
	"hotplug": _("Started automatically at boot"),
	// summary description of STARTMODE=ifplugd
	"ifplugd": _("Started automatically on cable connection"),
	// summary description of STARTMODE=managed
	"managed": _("Managed by NetworkManager"),
	// summary description of STARTMODE=off
	"off"	: _("Will not be started at all")
	];


  foreach(integer key, (list<integer>)Map::Keys(Items), {
   string rich = "";
   string ip =  _("Not configured");
   string descr = HardwareName (Hardware, Items[key, "hwinfo", "udi"]:"");
   descr = CheckEmptyName (type, descr);
   list <string> bullets = [];

   if (hasAnyValue(Items[key, "ifcfg"]:"") ){
    NetworkDevices::Select(Items[key, "ifcfg"]:"");
//    type = NetworkDevices::device_type(NetworkDevices::Name);
    type = Items[key, "hwinfo", "type"]:"";
    string dev = NetworkDevices::device_name(type, NetworkDevices::Name);
    ip = DeviceProtocol(NetworkDevices::Current);
    string status = DeviceStatus(type, NetworkDevices::device_num(NetworkDevices::Name), NetworkDevices::Current);


    string startmode_descr = startmode_descrs[NetworkDevices::Current["STARTMODE"]:""]:_("Started manually");

		bullets =  [
		    sformat(_("Device Name: %1"), dev),
		    startmode_descr,
		    ];
		if (NetworkDevices::Current["STARTMODE"]:"" != "managed")
		{
                 if (ip != "NONE")
		  {
		    bullets = bullets + [
			ip == "DHCP" ? _("IP address assigned using DHCP") :
			sformat(_("IP address: %1, subnet mask %2")
				, ip, NetworkDevices::Current["NETMASK"]:""),
			];
		  }
	// build aliases overview
	if (size(NetworkDevices::Current["_aliases"]:$[])>0 && !NetworkService::IsManaged()){
	 foreach(string key,   map<string, any> desc, (map<string ,map<string, any> >) NetworkDevices::Current["_aliases"]:$[], {
	 string parameters = sformat(_("IP address: %1, subnet mask %2"), desc["IPADDR"]:"", desc["NETMASK"]:"");
	 bullets = add(bullets, sformat("%1 (%2)", key, parameters) );
	 });
	}
		}

                // build the "Bond Slaves" entry of rich box
		if (type == "bond")
		{
/*
			string slaves = "";
			foreach (string key, any value, (map<string, any>)v, {
				if ((value != nil) && (regexpmatch(key, "BONDING_SLAVE[0-9]")))
					slaves = slaves + ((slaves != "") ? ", " : "") + (string)value;
			});
			if (slaves != "")
				bullets = bullets + [_("Bond slaves")+ " : " + slaves];
*/
		}
y2internal("%1\n%2", type, NetworkDevices::Current);
		if (type == "wlan" &&
		    !(NetworkDevices::Current["WIRELESS_AUTH_MODE"]:"" != "open") &&
		    !hasAnyValue(NetworkDevices::Current["WIRELESS_KEY_0"]:""))
		{
		    // avoid colons
		    dev = mergestring (splitstring (dev, ":"), "/");
		    string href = "lan--wifi-encryption-" + dev;
		    // interface summary: WiFi without encryption
		    string warning = HTML::Colorize (_("Warning: no encryption is used."), "red");
		    status = status + " " + warning + " " +
			// Hyperlink: Change the configuration of an interface
			Hyperlink (href, _("Change."));
		    links = add (links, href);
		}

    overview = add(overview, Summary::Device(descr, status));
        } else
		overview = add(overview, Summary::Device(descr, Summary::NotConfigured()));

	string conn = HTML::Bold ( (Items[key, "hwinfo", "link"]:false == true)?"":_("(not connected)") );
	string mac_dev="";
	if (hasAnyValue(Items[key, "hwinfo", "mac"]:"")) mac_dev= HTML::Bold ("MAC : ") + Items[key, "hwinfo", "mac"]:"" + "<br>";
	 else if (hasAnyValue(Items[key, "hwinfo", "busid"]:"")) mac_dev= HTML::Bold ("BusID : ") + Items[key, "hwinfo", "busid"]:"" + "<br>";
		rich = " " + conn + "<br>" + mac_dev;
		rich = HTML::Bold ( descr ) + rich;

   if (!hasAnyValue(Items[key, "hwinfo", "dev_name"]:""))
		rich = rich + _("<p>Unable to configure network card because kernel device is not present</p>");
	else if (hasAnyValue(Items[key, "ifcfg"]:"") ) rich = rich + HTML::List (bullets);
		else rich = rich + _("<P><UL><LI>The device is not configured</LI><LI>Press <B>Configure</B
> to configure</LI></UL></P>");


    Items[key, "table_descr"] = $[
		"rich_descr" : rich,
		"table_descr": [descr, ip]
		];
   });
 return [ Summary::DevicesList(overview), links ];
}


/**
 * Create an overview table with all configured devices
 * @return table items
 */
global list Overview() {
 BuildLanOverview();
 return GetDescr();
}

global boolean IsItemConfigured(){
 boolean ret = false;
 if (size(Items[current, "ifcfg"]:"")>0) ret = true;
 return ret;
}

global string GetItemDescription(){
 return Items[current, "table_descr", "rich_descr"]:"";
}


global map getCurrentItem(){
 return Items[current]:$[];
}

/**
 * Check if the given device has any virtual alias.
 * @param dev device to be checked
 * @return true if there are some aliases
 */
global define boolean InterfaceHasAliases() {
    return NetworkDevices::HasAliases(Items[current, "ifcfg"]:"");
}

/**
 * Select the hardware component
 * @param hw the component
 */
global void SelectHWMap (map hardware) {
//    sysfs_id = hardware["sysfs_id"]:"";
    map sel = SelectHardwareMap (hardware);

    /* common stuff */
    description = sel["name"]:"";
    type = sel["type"]:"eth";
    hotplug = sel["hotplug"]:"";

    unique = sel["udi"]:"";
    Requires = sel["requires"]:[];
    // #44977: Requires now contain the appropriate kernel packages
    // but they are handled differently due to multiple kernel flavors
    // (see Package::InstallKernel)
    // Leave only those not starting with "kernel".
    Requires = filter (string r, Requires, ``( search (r, "kernel") != 0 ));
    y2milestone ("requires=%1", Requires);

    // FIXME: devname
    hotplug = "";
    if(hotplug == "") {
	// FIXME: MOD Module["module"] = hw["module"]:"";
	// FIXME: MOD Module["options"] = hw["options"]:"";
	NetworkModules::Alias = hardware["module"]:"";
	NetworkModules::Options = hardware["options"]:"";
    }
    else
	y2milestone("HOTPLUG(%1) -> ignoring modprobe.conf", hotplug);

    // Wireless Card Features
    wl_auth_modes = prepend(hardware["wl_auth_modes"]:nilliststring, "no-encryption");
    wl_enc_modes = hardware["wl_enc_modes"]:nilliststring;
    wl_channels = hardware["wl_channels"]:nilliststring;
    wl_bitrates = hardware["wl_bitrates"]:nilliststring;

    string mac = hardware["mac"]:"";
    string busid = hardware["busid"]:"";


    nm_name = createHwcfgName(hardware, type);

    interfacename = hardware["dev_name"]:"";

    // name of ifcfg
    /* eth, tr, not on s390 (#38819) */
    if(!Arch::s390 () && mac != nil && mac != "" && mac != "00:00:00:00:00:00")
	device = "id-" + hardware["mac"]:"";
    /* iucv already filled in from lan/hardware.ycp (#42212) */
    else if(type == "iucv")
	y2debug("IUCV: %1", device);
    /* other devs */
    else if(busid != nil && busid != "")
	device = "bus-" + hardware["bus"]:"" + "-" + hardware["busid"]:"";
    /* USB, PCMCIA */
    else if(hardware["hotplug"]:"" != "")
	device = "bus-" + hardware["hotplug"]:"";
    /* dummy */
    else
	y2milestone("No detailed HW info: %1", device);

    y2milestone("hw=%1", hardware);
   y2milestone("device=%1", device);
   hw=hardware;
}

/**
 * Select the hardware component
 * @param which index of the component
 */

global define void SelectHW(integer which) {
    SelectHWMap (FindHardware (Hardware, which));
}



/*-------------------*/
/* PRIVATE FUNCTIONS */

/**
 * Return 10 free devices
 * @param type device type
 * @return list of 10 free devices
 */
global define list FreeDevices(string type) {
    return NetworkDevices::GetFreeDevices(type, 10);
}

/**
 * Return 10 free aliases
 * @param type device type
 * @param num device number
 * @return list of 10 free devices
 */
global define list FreeAliases(string type, integer num) {
    // FIXME: NI y2debug("Devices=%1", Devices);
    map Devices_1 = $[]; // FIXME: NI Devices[type, sformat("%1",num)]:$[];
    y2debug("Devices=%1", Devices_1);
    return NetworkDevices::GetFreeDevices("_aliases", 10);
}


/**
 * must be in sync with @ref SetDefaultsForHW
 */
global map GetDefaultsForHW () {
    map ret = $[];
    if (type == "wlan")
    {
	ret = union (
	    ret, $[
		"USERCONTROL": "yes", // #63767
		]);
    }
    // LCS eth interfaces on s390 need the MTU of 1492. #81815.
    // TODO: lcs, or eth?
    // will eth not get mapped to lcs?
    // Apparently both LCS eth and LCS tr are represented as "lcs"
    // but it does not hurt to change the default also for tr
    // #93798: limit to s390 to minimize regressions. Probably it could
    // be also done by only testing for lcs and not eth but that
    // would need more testing.
    else if (Arch::s390 () && contains (["lcs", "eth"], type))
    {
	y2milestone ("Adding LCS: setting MTU");
	ret = add (ret, "MTU", "1492");
    }
    return ret;
}

/**
 * must be in sync with @ref GetDefaultsForHW
 */
global define void SetDefaultsForHW () {
y2internal("SetDefaultsForHW type %1", type);
    if (type == "wlan")
    {
	usercontrol = true;
    }
    else if (Arch::s390 () && contains (["lcs", "eth"], type))
    {
	mtu = "1492";
    }
/*
 if (!needHwcfg(hw)){
		nm_name_old = nm_name;
		nm_name = "";
	}
 y2milestone("hwcfg name %1", nm_name);
*/
}

string GetDeviceVar (map primary, map fallback, string key) {
    string ret = (string) primary[key]:fallback[key]:nil;
    if (ret == nil)
    {
	y2debug ("%1 does not have a default defined", key);
    }
    return ret;
}


/**
 * Set various device variables
 * @param devmap map with variables
 * @return void
 */
global void SetDeviceVars(map devmap, map defaults) {
    /* address options */
    bootproto = GetDeviceVar (devmap, defaults, "BOOTPROTO");
    ipaddr = GetDeviceVar (devmap, defaults, "IPADDR");
    remoteip = GetDeviceVar (devmap, defaults, "REMOTE_IPADDR");
    netmask = GetDeviceVar (devmap, defaults, "NETMASK");

    mtu = GetDeviceVar (devmap, defaults, "MTU");
    ethtool_options = GetDeviceVar (devmap, defaults, "ETHTOOL_OPTIONS");
    startmode = GetDeviceVar (devmap, defaults, "STARTMODE");
    usercontrol = GetDeviceVar (devmap, defaults, "USERCONTROL") == "yes";
    description = GetDeviceVar (devmap, defaults, "NAME");
    bond_option = GetDeviceVar(devmap, defaults, "BONDING_MODULE_OPTS");

    bond_slaves=[];
    foreach(any key, any value, devmap,
    {
        if (regexpmatch((string)key, "BONDING_SLAVE[0-9]+"))
            if ((string)value != nil)
                bond_slaves = add(bond_slaves, (string)value);
    });

    /* wireless options */
    wl_mode = GetDeviceVar (devmap, defaults, "WIRELESS_MODE");
    wl_essid = GetDeviceVar (devmap, defaults, "WIRELESS_ESSID");
    wl_nwid = GetDeviceVar (devmap, defaults, "WIRELESS_NWID");
    wl_auth_mode = GetDeviceVar (devmap, defaults, "WIRELESS_AUTH_MODE");
    wl_wpa_psk = GetDeviceVar (devmap, defaults, "WIRELESS_WPA_PSK");
    wl_key_length = GetDeviceVar (devmap, defaults, "WIRELESS_KEY_LENGTH");
    wl_key = []; // ensure exactly 4 entries
    wl_key[0] = GetDeviceVar (devmap, defaults, "WIRELESS_KEY_0");
    if (wl_key[0]:"" == "")
    {
	wl_key[0] = GetDeviceVar (devmap, defaults, "WIRELESS_KEY");
    }
    wl_key[1] = GetDeviceVar (devmap, defaults, "WIRELESS_KEY_1");
    wl_key[2] = GetDeviceVar (devmap, defaults, "WIRELESS_KEY_2");
    wl_key[3] = GetDeviceVar (devmap, defaults, "WIRELESS_KEY_3");

    wl_default_key = tointeger (GetDeviceVar (devmap, defaults, "WIRELESS_DEFAULT_KEY"));
    wl_nick = GetDeviceVar (devmap, defaults, "WIRELESS_NICK");

    wl_wpa_eap = $[];
    wl_wpa_eap["WPA_EAP_MODE"] = GetDeviceVar (devmap, defaults, "WIRELESS_EAP_MODE");
    wl_wpa_eap["WPA_EAP_IDENTITY"] = GetDeviceVar (devmap, defaults, "WIRELESS_WPA_IDENTITY");
    wl_wpa_eap["WPA_EAP_PASSWORD"] = GetDeviceVar (devmap, defaults, "WIRELESS_WPA_PASSWORD");
    wl_wpa_eap["WPA_EAP_ANONID"] = GetDeviceVar (devmap, defaults, "WIRELESS_WPA_ANONID");
    wl_wpa_eap["WPA_EAP_CLIENT_CERT"] = GetDeviceVar (devmap, defaults, "WIRELESS_CLIENT_CERT");
    wl_wpa_eap["WPA_EAP_CLIENT_KEY"] = GetDeviceVar (devmap, defaults, "WIRELESS_CLIENT_KEY");
    wl_wpa_eap["WPA_EAP_CLIENT_KEY_PASSWORD"] = GetDeviceVar (devmap, defaults, "WIRELESS_CLIENT_KEY_PASSWORD");
    wl_wpa_eap["WPA_EAP_CA_CERT"] = GetDeviceVar (devmap, defaults, "WIRELESS_CA_CERT");
    wl_wpa_eap["WPA_EAP_AUTH"] = GetDeviceVar (devmap, defaults, "WIRELESS_EAP_AUTH");
    wl_wpa_eap["WPA_EAP_PEAP_VERSION"] = GetDeviceVar (devmap, defaults, "WIRELESS_PEAP_VERSION");

    wl_channel = GetDeviceVar (devmap, defaults, "WIRELESS_CHANNEL");
    wl_frequency = GetDeviceVar (devmap, defaults, "WIRELESS_FREQUENCY");
    wl_bitrate = GetDeviceVar (devmap, defaults, "WIRELESS_BITRATE");
    wl_accesspoint = GetDeviceVar (devmap, defaults, "WIRELESS_AP");
    wl_power = GetDeviceVar (devmap, defaults, "WIRELESS_POWER") == "yes";

    /* s/390 options */
    portname = GetDeviceVar (devmap, defaults, "PORTNAME");
    
    aliases = devmap["_aliases"]:$[];

    return;
}


/**
 * the defaults here are what sysconfig defaults to
 * (as opposed to what a new interface gets, in @ref Select)
 */
global map<string, string> SysconfigDefaults = $[
    "BOOTPROTO": "static",
    "IPADDR": "",
    "REMOTE_IPADDR": "",
    "NETMASK": "",
    "MTU": "",
    "ETHTOOL_OPTIONS": "",
    "NAME": "",
    "STARTMODE": "manual",
    "USERCONTROL": "no",
    "WIRELESS_MODE": "Managed",
    "WIRELESS_ESSID": "",
    "WIRELESS_NWID": "",
    "WIRELESS_AUTH_MODE": "open",
    "WIRELESS_WPA_PSK": "",
    "WIRELESS_KEY_LENGTH": "128",
    "WIRELESS_KEY": "",
    "WIRELESS_KEY_0": "",
    "WIRELESS_KEY_1": "",
    "WIRELESS_KEY_2": "",
    "WIRELESS_KEY_3": "",
    "WIRELESS_DEFAULT_KEY": "0",
    "WIRELESS_NICK": "",
    "WIRELESS_WPA_IDENTITY": "",
    "WIRELESS_WPA_PASSWORD": "",
    "WIRELESS_CLIENT_CERT": "",
    "WIRELESS_CA_CERT": "",
    "WIRELESS_CHANNEL": "",
    "WIRELESS_FREQUENCY": "",
    "WIRELESS_BITRATE": "auto",
    "WIRELESS_AP": "",
    "WIRELESS_POWER": "yes",
    "PORTNAME": "", 
    // aliases = devmap["_aliases"]:$[]; // ?
    "WIRELESS_EAP_MODE": "",
    "WIRELESS_WPA_IDENTITY": "",
    "WIRELESS_WPA_PASSWORD": "",
    "WIRELESS_WPA_ANONID": "",
    "WIRELESS_CLIENT_CERT": "",
    "WIRELESS_CLIENT_KEY": "",
    "WIRELESS_CLIENT_KEY_PASSWORD": "",
    "WIRELESS_CA_CERT": "",
    "WIRELESS_EAP_AUTH": "",
    "WIRELESS_PEAP_VERSION": "",

    "BONDING_MODULE_OPTS": "",
    ];

global list<string> GetItemUdev(){
// column: 0 mens rule, 1 means device
 list<string> udevs=["", ""];
 if (size(Items[current, "udev"]:[])>3)
 {
  udevs[0]=Items[current, "udev", 2]:"";
  if (regexpmatch (Items[current, "udev", 3]:"", ".* [^ ]*\"$")) {
    udevs[1]=regexpsub (Items[current, "udev", 3]:"", ".* ([^ ]*)\"$", "\\1");
  }
 }
 return udevs;
}

/**
 * Select the given device
 * @param dev device to select ("" for new device, default values)
 * @return true if success
 */
global define boolean Select(string dev) {
    y2debug("dev=%1", dev);
    map devmap = $[];
    /* dev=="" -> Add */
//    if(dev == "") {
	// defaults for a new device
	devmap = $[
	    "STARTMODE": "auto",	// #115448, #156388
	    "NETMASK": (NetHwDetection::result["NETMASK"]:"255.255.255.0"), // #31369
	    ];
	string product_startmode = ProductFeatures::GetStringFeature ("network", "startmode");
	if (contains (["auto", "ifplugd"], product_startmode))
	{
	    y2milestone ("Product startmode: %1", product_startmode);
	    if (product_startmode == "ifplugd" && ! Arch::is_laptop ())
	    {
		// #164816
		y2milestone ("Not a laptop, will not prefer ifplugd");
		product_startmode = "auto";
	    }
	    devmap["STARTMODE"] = product_startmode;
	}

	type = LanItems::Items[LanItems::current, "hwinfo", "type"]:"eth";
//        type = "eth0";
	device = NetworkDevices::GetFreeDevice(type);

	// FIXME: MOD AddModule(type);
//	NetworkModules::AddM();
//	nm_name = NetworkModules::GetFreeName("static-");

	NetworkDevices::Name = GetItemUdev()[1]:"";
	LanItems::Items[LanItems::current, "ifcfg"] = NetworkDevices::Name;

//	interfacename = GetItemUdev()[1]:"";
//	y2internal("interfacename %1", interfacename);

	/* FIXME: alias: how to prefill new alias? */
	alias = "";
//    }
    /* dev!="" -> Edit */
/* FIXME: NI:
    else {
	if(!CheckDevice(dev)) {
	    y2error("Device not found: %1", dev);
	    return false;
	}
	NetworkDevices::Edit(dev);
	devmap = NetworkDevices::Current;
	type = NetworkDevices::device_type(dev);
	device = NetworkDevices::device_num(dev);
	alias = NetworkDevices::alias_num(dev);
    }
*/
    /* general stuff */
    description = BuildDescription (type, device, devmap, Hardware);

    unique = devmap["udi"]:"";
    SetDeviceVars(devmap, SysconfigDefaults);


    hotplug = "";
    /*
    if(issubstring(device, "bus-pcmcia"))
	hotplug = "pcmcia";
    else if(issubstring(device, "bus-usb"))
	hotplug = "usb";
    */

    y2debug("type=%1", type);
    if(issubstring(type, "-"))
	type = regexpsub(type, "([^-]+)-.*$", "\\1");
    y2debug("type=%1", type);

    /* kernel options */
    if(hotplug == "" && alias == "" && nm_name != "") {
	// FIXME: MOD SelectModule(dev);
	NetworkModules::SelectM(nm_name);
    }
    else {
	// FIXME: MOD SelectModule("");
	NetworkModules::AddM();
    }

    qeth_options = NetworkModules::QETH_OPTIONS;
    chan_mode = NetworkModules::CCW_CHAN_MODE;
    lcs_timeout = NetworkModules::LCS_LANCMD_TIMEOUT;

    if (NetworkModules::QETH_IPA_TAKEOVER == nil ||
	NetworkModules::QETH_IPA_TAKEOVER == "" ||
	NetworkModules::QETH_IPA_TAKEOVER == "0")
	ipa_takeover = false;
    else
	ipa_takeover = true;

    if (NetworkModules::QETH_LAYER2_SUPPORT == nil ||
	NetworkModules::QETH_LAYER2_SUPPORT == "" ||
	NetworkModules::QETH_LAYER2_SUPPORT == "0")
	qeth_layer2 = false;
    else
	qeth_layer2 = true;

    /* We always have to set the MAC Address for qeth Layer2 support */
    if (qeth_layer2 ) {
	qeth_macaddress = devmap["LLADDR"]:"00:00:00:00:00:00";
    }

    //if(bootproto == "none") bootproto = "static";

    return true;
}

// ifplugd sometimes does not work for wifi
// so wired needs higher priority to override it
map <string, string> ifplugd_priorities = $[
    "eth": "20",
    "wlan": "10",
    ];


/**
 * Commit pending operation
 * @return true if success
 */
global define boolean Commit() {

    if(operation == `add || operation == `edit) {
	map<string,any> newdev = $[];

	// #104494 - always write IPADDR+NETMASK, even empty
	newdev["IPADDR"] = ipaddr;
	newdev["NETMASK"] = netmask;
	// #50955 omit computable fields
	newdev["BROADCAST"] = "";
	newdev["NETWORK"] = "";

	newdev["REMOTE_IPADDR"] = remoteip;

	if(alias == "") {
	    newdev["MTU"] = mtu;
	    newdev["ETHTOOL_OPTIONS"] = ethtool_options;
	    newdev["STARTMODE"] = startmode;
	    // it is not in Select yet because we don't have a widget for it
	    if (startmode == "ifplugd")
	    {
		string prio = ifplugd_priorities[type]:"";
		newdev["IFPLUGD_PRIORITY"] = prio;
	    }
	    newdev["USERCONTROL"] = usercontrol? "yes": "no";
	    newdev["BOOTPROTO"] = bootproto;
	    newdev["NAME"] = description;
	}

//	if(unique != "" && unique != nil) newdev["udi"] = unique;
/*
	if(hotplug == "") {
	    if(alias == "") {
		// FIXME: MOD ChangeModule(NetworkDevices::device_name(type, device), operation == `add);
		y2milestone("HWCFG name %1 (%2)", nm_name, nm_name_old);
		if(hasAnyValue(nm_name) && operation == `edit &&
			hasAnyValue(nm_name_old) && nm_name != nm_name_old) {
		    y2milestone("HWCFG name change (%1) -> deleting old (%2)", nm_name, nm_name_old);
		    NetworkModules::DeleteM(nm_name_old);
		    nm_name_old = nil;
		}

		if(Arch::s390 ()) {
		    string type2 = DriverType (type);
		    if(type2 == "iucv") {
			NetworkModules::SCRIPTUP = "hwup-iucv";
		    }
		    else {
			NetworkModules::SCRIPTUP = "hwup-ccw";
			NetworkModules::SCRIPTUP_ccw = "hwup-ccw";
			NetworkModules::SCRIPTDOWN = "hwdown-ccw";
			NetworkModules::SCRIPTUP_ccwgroup = "hwup-" + type2;
		    }

		    integer devid = 0;
		    string devstr = "";

		    y2milestone("nm_name=%1", nm_name);
		    string s390chanid = "[0-9]+\\.[0-9]+\\.";
		    if(regexpmatch(nm_name, s390chanid)) {
			devid = tointeger("0x" + regexpsub(nm_name, s390chanid + "(.*)", "\\1"));
			devstr = regexpsub(nm_name, ".*[^0-9](" + s390chanid + ").*", "\\1");
		    }

		    y2milestone("devid=%1(%2)", devid, devstr);
		    if(devid == nil) devid = 0;
		    string devid0 = String::PadZeros(regexpsub(tohexstring(devid), "0x(.*)", "\\1"), 4);
		    string devid1 = String::PadZeros(regexpsub(tohexstring(devid+1), "0x(.*)", "\\1"), 4);
		    string devid2 = String::PadZeros(regexpsub(tohexstring(devid+2), "0x(.*)", "\\1"), 4);

		    if(type2 == "ctc" || type2 == "lcs") {
			NetworkModules::CCW_CHAN_IDS = sformat("%1%2 %1%3", devstr, devid0, devid1);
			NetworkModules::CCW_CHAN_MODE = chan_mode;
			NetworkModules::CCW_CHAN_NUM = "2";
			NetworkModules::LCS_LANCMD_TIMEOUT = lcs_timeout;
		    }
		    else if(type2 == "qeth") {
			NetworkModules::CCW_CHAN_IDS = sformat("%1%2 %1%3 %1%4", devstr, devid0, devid1, devid2);
			NetworkModules::CCW_CHAN_MODE = chan_mode;
			NetworkModules::CCW_CHAN_NUM = "3";
			NetworkModules::QETH_OPTIONS = qeth_options;
			NetworkModules::QETH_IPA_TAKEOVER = ipa_takeover? "1": "0";
			NetworkModules::QETH_LAYER2_SUPPORT = qeth_layer2? "1": "0";
			if (qeth_layer2 && qeth_macaddress != "00:00:00:00:00:00") {
			    newdev["LLADDR"] = qeth_macaddress;
			}
			else {
			    // #151196: layer 3 otherwise fails
			    newdev["LLADDR"] = "";
			}
		    }

		}

		// If "", no hwcfg is created. See also #42421.
		if (NetworkModules::ChangeM(nm_name)) Items[current, "hwcfg"]=nm_name;
			else Items[current, "hwcfg"]="";
	    }
	}
*/

	if(hotplug == "pcmcia") newdev["DHCLIENT_SET_DOWN_LINK"] = "yes";


	if (type == "bond")
	{
            integer i = 0;
            foreach (string slave, bond_slaves,
            {
		newdev[sformat("BONDING_SLAVE%1", i)] = slave;
                i = i + 1;
            });

            //assign nil to rest BONDING_SLAVEn to remove them
            while (i<10)
            {
               newdev[sformat("BONDING_SLAVE%1", i)] = nil;
               i = i + 1;
            };

            newdev["BONDING_MODULE_OPTS"] = bond_option;

            //BONDING_MASTER always is yes
            newdev["BONDING_MASTER"] = "yes";
	}

	if(type == "wlan") {
	    newdev["WIRELESS_MODE"] = wl_mode;
	    newdev["WIRELESS_ESSID"] = wl_essid;
	    newdev["WIRELESS_NWID"] = wl_nwid;
	    newdev["WIRELESS_AUTH_MODE"] = wl_auth_mode;
	    newdev["WIRELESS_WPA_PSK"] = wl_wpa_psk;
	    newdev["WIRELESS_KEY_LENGTH"] = wl_key_length;
	    // obsoleted by WIRELESS_KEY_0
	    newdev["WIRELESS_KEY"] = ""; // TODO: delete the varlable
	    newdev["WIRELESS_KEY_0"] = wl_key[0]:"";
	    newdev["WIRELESS_KEY_1"] = wl_key[1]:"";
	    newdev["WIRELESS_KEY_2"] = wl_key[2]:"";
	    newdev["WIRELESS_KEY_3"] = wl_key[3]:"";
	    newdev["WIRELESS_DEFAULT_KEY"] = tostring (wl_default_key);
	    newdev["WIRELESS_NICK"] = wl_nick;

	    if (wl_wpa_eap != $[])
	    {
		newdev["WIRELESS_EAP_MODE"] = wl_wpa_eap["WPA_EAP_MODE"]:"";
		newdev["WIRELESS_WPA_IDENTITY"] = wl_wpa_eap["WPA_EAP_IDENTITY"]:"";
		newdev["WIRELESS_WPA_PASSWORD"] = wl_wpa_eap["WPA_EAP_PASSWORD"]:"";
		newdev["WIRELESS_WPA_ANONID"] = wl_wpa_eap["WPA_EAP_ANONID"]:"";
		newdev["WIRELESS_CLIENT_CERT"] = wl_wpa_eap["WPA_EAP_CLIENT_CERT"]:"";
		newdev["WIRELESS_CLIENT_KEY"] = wl_wpa_eap["WPA_EAP_CLIENT_KEY"]:"";
		newdev["WIRELESS_CLIENT_KEY_PASSWORD"] = wl_wpa_eap["WPA_EAP_CLIENT_KEY_PASSWORD"]:"";
		newdev["WIRELESS_CA_CERT"] = wl_wpa_eap["WPA_EAP_CA_CERT"]:"";
		newdev["WIRELESS_EAP_AUTH"] = wl_wpa_eap["WPA_EAP_AUTH"]:"";
		newdev["WIRELESS_PEAP_VERSION"] = wl_wpa_eap["WPA_EAP_PEAP_VERSION"]:"";	    
	    }

	    newdev["WIRELESS_CHANNEL"] = wl_channel;
	    newdev["WIRELESS_FREQUENCY"] = wl_frequency;
	    newdev["WIRELESS_BITRATE"] = wl_bitrate;
	    newdev["WIRELESS_AP"] = wl_accesspoint;
	    newdev["WIRELESS_POWER"] = wl_power ? "yes" : "no";
	}

//	if(hasAnyValue(nm_name)) newdev["_nm_name"] = nm_name;

	if(DriverType (type) == "ctc")
	    if(NetworkConfig::Config["WAIT_FOR_INTERFACES"]:nil == nil || NetworkConfig::Config["WAIT_FOR_INTERFACES"]:0 < 40)
		NetworkConfig::Config["WAIT_FOR_INTERFACES"] = 40;

	/* FIXME: MOD
	if(DriverType (type) == "qeth")
	    if(NetworkConfig::Config["WAIT_FOR_INTERFACES"]:nil == nil || NetworkConfig::Config["WAIT_FOR_INTERFACES"]:0 < 15)
		NetworkConfig::Config["WAIT_FOR_INTERFACES"] = 15;
	*/

	if(alias == "") {
	    newdev["_aliases"] = aliases;
	    y2milestone("aliases %1", aliases);
	}

	NetworkDevices::Name = interfacename;
	NetworkDevices::Current = newdev;
	if (NetworkDevices::Commit()) Items[current, "ifcfg"]=interfacename;
    }
    else {
	y2error("Unknown operation: %1", operation);
	return false;
    }
   nm_name_old = nil;
   modified = true;
   operation = nil;
   return true;
}

/**
 * Get the module configuration for the modules configured in the 
 * interface section
 * @param ay_device Device, for example eth0
 * @param ay_modules list of modules from the AY profile
 * @return map the module map with module name and options
 */
global map GetModuleForInterface(string ay_device ,
				    list<map> ay_modules) {
    map ayret = $[];
    list<map> ay_filtered = filter(map ay_m, ay_modules,
				  ``(
				     ay_m["device"]:"" == ay_device ));
    
    if (size(ay_filtered) > 0 ) {
	ayret = ay_filtered[0]:$[];
    }

    return ayret;
}


/**
 * Find matching device 
 * Find a device, optionally with some predefined values
 * @param interface interface map 
 * @return map The map of the matching device.
 */
global map FindMatchingDevice(map interface) {
    map tosel = nil;
    // Minimal changes to code to fix both #119592 and #146965
    // Alternatively we could try to ensure that we never match a
    // device that got already matched
    boolean matched_by_module = false;

    list<string> devs = NetworkDevices::List("netcard");
    y2milestone("Configured devices: %1", devs );

    // this condition is always true for SLES9, HEAD uses $[] for proposal
    if (interface != $[])
    {
	// Notes for comments about matching:
	// - interface["device"] is the key which we look for in the actual hw
	// - H iterates over Hardware
	// - patterns are shell-like

        list device_id = splitstring(interface["device"]:"", "-");
        /* code for eth-id-00:80:c8:f6:48:4c configurations */
	// *-id-$ID => find H["mac"] == $ID
        if (size(device_id)> 1 && device_id[1]:"" == "id")
        {
            string hwaddr = device_id[2]:"";
            if(hwaddr != nil && hwaddr != "") {
                tosel = find (map h, Hardware, ``( h["mac"]:"" == hwaddr ));
            }			
            y2milestone("Rule: matching mac in device name");
        }
        /* code for eth-bus-pci-0000:00:0d.0 configurations */
        /* code for eth-bus-vio-30000001 configurations */
	// *-bus-$BUS-$ID => find H["bus"] == $BUS & H["busid"] == $ID
        else if (size(device_id)> 2 && device_id[1]:"" == "bus")
        {
	    string bus = device_id[2]:"";
            string busid = device_id[3]:"";
            if(bus != nil && bus != "" && busid != nil && busid != "") {
                tosel = find (map h, Hardware, ``( h["busid"]:"" == busid
                            && h["bus"]:"" == bus ));
            }	
            y2milestone("Rule: matching bus id in device name");
        }

        /* code for module configuration */
	// join with the modules list of the ay profile according to "device"
	// if exists => find H["module"] == AH["module"]
        map aymodule = GetModuleForInterface(interface["device"]:"", 
                autoinstall_settings["modules"]:[]);
        y2milestone("module data: %1", aymodule );
        if (tosel == nil && aymodule != $[]) {
            if(aymodule != nil && aymodule["module"]:"" != "") {
                tosel = find (map h, LanItems::Hardware, ``( h["module"]:"" == aymodule["module"]:"" ));
            }
	    if (tosel != nil)
	    {
		matched_by_module = true;
	    }
            y2milestone("Rule: matching module configuration");
        }
    }
    
    // First device was already configured, we are now looking for 
    // a second (third,...) one
    if (size(devs) > 0 )
    {
        // #119592, #146965: this used to be unconditional, overwriting the
        // results of the above matching.	
	if (matched_by_module || tosel == nil)
	{
	    // go thru all devices, check whether there's one that does
	    // not have a configuration yet
	    // and has the same type as the current profile item
	    foreach (map h, LanItems::Hardware, {
		y2milestone("Checking for device=%1", h);
		SelectHWMap(h);
		string _device_name = NetworkDevices::device_name(NetworkDevices::RealType(type, hotplug), device);
		if (!NetworkDevices::Check(_device_name) &&
		    type == NetworkDevices::device_type(interface["device"]:"")
		    )
		{
		    y2milestone("Selected: %1", h );
		    tosel = h;
		    break;
		}
	    });
	}
        if (tosel == nil )
        {
            y2error("Nothing found");
        }

    } else {
	// this is the first interface, match the hardware with install.inf
/*
 // couldn't happen 
	if (size(InstallInf)>0){
         // Select the one from install.inf with the same MAC 
	 // find H["mac"] == InstallInf["hwaddr"]
         if (tosel == nil  ) {
            string hwaddr = InstallInf["hwaddr"]:"";
            if(hwaddr != nil && hwaddr != "") {
                tosel = find (map h, Hardware, ``( h["mac"]:"" == hwaddr ));
            }
            y2milestone("Rule: matching hwaddr in install.inf");
         }

         // Select the one from install.inf with the same module 
	 // find H["module"] == InstallInf["module"]
         if (tosel == nil) {
            string infmodule = InstallInf["module"]:"";
            if(infmodule != nil && infmodule != "") {
                tosel = find (map h, Hardware, ``( h["module"]:"" == infmodule ));
            }
            y2milestone("Rule: matching module in install.inf");
         }
	} else
*/
	   {
	 /* No install.inf -> select the first connected */
         // find H["active"] == true
         if (tosel == nil) {
            tosel = find (map h, LanItems::Hardware, ``(
                        h["link", "state"]:false
                        ));
            y2milestone("Rule: first connected");
         }
	}

        /* No install.inf driver -> select the first active */
	// find H["active"] == true
        if (tosel == nil) {
            tosel = find (map h, LanItems::Hardware, ``(
                        h["active"]:false
                        ));
            y2milestone("Rule: first active");
        }

        /* No active driver -> select the first with a driver */
	// find H["module"] != ""
        if (tosel == nil) {
            y2milestone("No active driver found, trying further.");
            tosel = find (map h, LanItems::Hardware, ``(
                        h["module"]:"" != ""
                        && y2milestone("Using driver: %1", h) == nil
                        ));
            y2milestone("Rule: first with driver");
        }
    }

    return tosel;
}

global void DeleteItem(){
 y2internal("deleting ... %1", Items[current]:$[]);
 string ifcfg = Items[current, "ifcfg"]:"";
 string hwcfg = Items[current, "hwcfg"]:"";

 if (hasAnyValue(ifcfg)) {
	 NetworkDevices::Delete(ifcfg);
	 NetworkDevices::Commit();
	 Items[current, "ifcfg"] = "";
	}
 if (hasAnyValue(hwcfg)) {
	 NetworkModules::DeleteM(hwcfg);
	 Items[current, "hwcfg"] = "";
	}
 if (! (size(Items[current, "hwinfo"]:$[])>0) ){
  map<integer, any> tmp_items = $[];
  foreach(integer key, any value, Items, {
   if (key==current) continue;
    else{
	if (key<current) tmp_items[key]=Items[key]:$[];
		else tmp_items[key-1]=Items[key]:$[];
	}
  });
  Items = tmp_items;
 }
 SetModified();
}

global void SetItem(){
 operation = `edit;
 interfacename = Items[current, "ifcfg"]:"";
 NetworkDevices::Edit(Items[current, "ifcfg"]:"");
 map devmap = NetworkDevices::Current;
 type = Items[current, "hwinfo", "type"]:"";
 device = NetworkDevices::device_num(Items[current, "ifcfg"]:"");
 alias = NetworkDevices::alias_num(Items[current, "ifcfg"]:"");
 nm_name = Items[current, "hwcfg"]:"";
 if (nm_name=="") nm_name_old = createHwcfgName(Items[current, "hwinfo"]:$[], type);
  NetworkModules::SelectM(nm_name);

    /* general stuff */
    description = BuildDescription (type, device, devmap, Hardware);

    unique = devmap["udi"]:"";
    SetDeviceVars(devmap, SysconfigDefaults);


    hotplug = "";

    y2debug("type=%1", type);
    if(issubstring(type, "-")) type = regexpsub(type, "([^-]+)-.*$", "\\1");
    y2debug("type=%1", type);

    /* kernel options */
    if(hotplug == "" && alias == "" && nm_name != "") {
	// FIXME: MOD SelectModule(dev);
	NetworkModules::SelectM(nm_name);
    }
    else {
	// FIXME: MOD SelectModule("");
	NetworkModules::AddM();
    }

    qeth_options = NetworkModules::QETH_OPTIONS;
    chan_mode = NetworkModules::CCW_CHAN_MODE;
    lcs_timeout = NetworkModules::LCS_LANCMD_TIMEOUT;

    if (NetworkModules::QETH_IPA_TAKEOVER == nil ||
	NetworkModules::QETH_IPA_TAKEOVER == "" ||
	NetworkModules::QETH_IPA_TAKEOVER == "0")
	ipa_takeover = false;
    else
	ipa_takeover = true;

    if (NetworkModules::QETH_LAYER2_SUPPORT == nil ||
	NetworkModules::QETH_LAYER2_SUPPORT == "" ||
	NetworkModules::QETH_LAYER2_SUPPORT == "0")
	qeth_layer2 = false;
    else
	qeth_layer2 = true;

    /* We always have to set the MAC Address for qeth Layer2 support */
    if (qeth_layer2 ) {
	qeth_macaddress = devmap["LLADDR"]:"00:00:00:00:00:00";
    }

}

global void AddNew(){
 y2internal("Name %1", NetworkDevices::Name);
 current = size(Items)+1;
}

global boolean ProposeItemConfiguration(){
 y2milestone("Propose configuration for %1", getCurrentItem());
  operation = nil;
  if(Select("") != true) return false;
  SetDefaultsForHW ();
  ipaddr = "";
  bootproto = "dhcp";
    // #176804
    if (NetworkStorage::isDiskOnNetwork ( NetworkStorage::getDevice("/") ))
    {
	startmode = "nfsroot";
	y2milestone ("startmode nfsroot");
    }
  NetworkDevices::Add();
  operation = `edit;
  interfacename=getCurrentItem()["hwinfo", "dev_name"]:"";
  Commit ();
 y2milestone("After configuration propose %1", getCurrentItem());
 return true;
}

}
