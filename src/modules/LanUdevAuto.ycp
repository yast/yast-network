/**
 * File:        modules/LanUdevAuto.ycp
 * Package:     Network configuration
 * Summary:     Udev rules for autoinstallation
 * Authors:     Michal Zugec <mzugec@suse.cz>
 *
 * $Id: Lan.ycp 40537 2007-08-28 13:22:01Z mzugec $
 *
 * Representation of the configuration of network cards.
 */

{
 module     "LanUdevAuto";
 import "LanItems";
 include "network/routines.ycp";

 textdomain "network";

 list<map> udev_rules=[];
 list<map> s390_devices=[];
 list <map> hardware=nil;

global string getDeviceName(string oldname){
 string newname=oldname;
 if (hardware==nil) hardware=ReadHardware("netcard");

   if (issubstring(oldname, "-id-")){
    y2milestone("device by ID found %1", oldname);

   string mac_from_ay = splitstring(tostring(oldname), "-")[2]:"";
    y2milestone("MAC address from AY : %1", mac_from_ay);
    foreach(map hw, hardware, {
     y2internal("hw %1", hw["mac"]:"");
     if (hw["mac"]:""==mac_from_ay){
      y2milestone("device matched : %1", hw["dev_name"]:"");
      newname = hw["dev_name"]:"";
     }
    });
   }

   else if (issubstring(oldname, "-bus-")){
    y2milestone("device by BUS found %1", oldname);
    string bus_from_ay = splitstring(tostring(oldname), "-")[2]:"";
    y2milestone("BUSID from AY : %1", bus_from_ay);
    foreach(map hw, hardware, {
     y2internal("hw %1", hw["busid"]:"");
     if (hw["busid"]:""==bus_from_ay){
      y2milestone("device matched : %1", hw["dev_name"]:"");
      newname = hw["dev_name"]:"";
     }
    });
   }
 if (oldname==newname) y2milestone("nothing changed, %1 is old style dev_name", newname);
 return newname;
}

/**
 *  internal function:
 *  check if old-style (ifcfg-eth-id-..., ifcfg-eth-bus-... is used) or new-style (ifcfg-eth0)
 */
 boolean oldStyle(map ay){
  boolean old_style_found = false;
  foreach(map interface, ay["interfaces"]:[], {
   if (issubstring(interface["device"]:"", "-id-")) old_style_found=true;
   if (issubstring(interface["device"]:"", "-bus-")) old_style_found=true;
  });
  y2milestone("old-style found:%1", old_style_found);
  return old_style_found;
 }

/**
 *  internal function:
 *  for old-slyle create udev rules and rename interface names to new-style
 */
 list<map> createUdevFromIfaceName(list<map> interfaces){
  y2milestone("old-style names for interfaces found - convert into new-style");
  y2internal("interfaces %1", interfaces);
  list<map> tmp_interfaces=[];
  foreach(map interface, interfaces, {
   if (issubstring(interface["device"]:"", "-id-")||issubstring(interface["device"]:"", "-bus-")){
    string value = splitstring(interface["device"]:"", "-")[2]:"";
    string rule="ATTR{address}";
    if (splitstring(interface["device"]:"", "-")[1]:"" == "bus") rule = "KERNELS";
    udev_rules = add(udev_rules,
				$[
				  "rule"  : rule,
				  "value" : value,
				  "name"  : getDeviceName( interface["device"]:"" )
				 ]);
    tmp_interfaces=add(tmp_interfaces, interface);
   }
  });
  y2milestone("converted interfaces: %1", tmp_interfaces);
  return tmp_interfaces;
 }

 global define boolean Import(map settings) {
y2milestone("importing %1", settings);
  if (oldStyle(settings)) settings["interfaces"] = createUdevFromIfaceName(settings["interfaces"]:[]);
	else udev_rules = settings["net-udev"]:[];
/*  if (Arch::s390())*/ s390_devices=settings["s390-devices"]:[];
  y2internal("interfaces: %1", settings["interfaces"]:[]);
  y2internal("net-udev rules:%1", udev_rules);
  y2internal("s390-devices rules:%1", s390_devices);
  return true;
 }

 global define boolean Write(){
 list<string> comment = ["# Generated by autoyast",
			"# program run by the persistent-net-generator.rules rules file.",
			"#",
			"# You can modify it, as long as you keep each rule on a single line." ];
  list<string> rules = [];
  foreach(map rule, udev_rules, {
   rules = add(rules, sformat("SUBSYSTEM==\"net\", ACTION==\"add\", DRIVERS==\"?*\", %1==\"%2\", NAME=\"%3\"",
						rule["rule"]:"", rule["value"]:"", rule["name"]:""));
  });
  if (size(rules)>0){
   y2milestone("Writing AY udev rules for network (will replace original rules from 1st stage)");
   SCR::Write(.udev_persistent.rules_comment, comment);
   SCR::Write(.udev_persistent.rules, rules);
  } else
     y2milestone("No udev rules defined by AY, nothing to write (keep original file)");
  if (Arch::s390()){
   foreach(map rule, s390_devices, {
    LanItems::Select("");
    LanItems::type=rule["type"]:"";
    LanItems::qeth_chanids=rule["chanids"]:"";
    LanItems::qeth_layer2 = rule["layer2"]:false;
    switch(rule["type"]:""){
     case "qeth":
		LanItems::chan_mode=rule["portname"]:"";
		break;
     case "ctc":
		LanItems::chan_mode=rule["protocol"]:"";
		break;
     case "iucv":
		LanItems::chan_mode=rule["router"]:"";
		break;
    }
    LanItems::createS390Device();
    y2internal("rule %1", rule);
   });
   y2internal("Writing s390 rules %1", s390_devices);
  }
  return true;
 }

global map Export(map devices){
 map AY=$["s390-devices":$[], "net-udev":$[]];
 if (Arch::s390()){
  list<string> devs=[];
  foreach(string type, any value, (map<string, any>)devices, {
   devs = (list<string>)union((list)devs, Map::Keys((map)value));
  });
  foreach(string device, devs, {
   map<string, any> driver=(map<string, any>)SCR::Execute(.target.bash_output, sformat("driver=$(ls -l /sys/class/net/%1/device/driver);echo ${driver##*/}|tr -d '\n'", device));
   string device_type="";
   string chanids="";
   string portname="";
   string protocol="";
   if(driver["exit"]:-1==0){
    switch(driver["stdout"]:""){
     case "qeth":
	device_type=driver["stdout"]:"";
	break;
     case "ctcm":
	device_type="ctc";
	break;
     case "netiucv":
	device_type="iucv";
	break;
     default:
	y2error("unknown driver type :%1", driver["stdout"]:"");
    }
   } else{
    y2error("%1", driver);
    continue;
   }
  map <string, any> chan_ids=(map<string, any>)SCR::Execute(.target.bash_output,
		sformat("for i in $(seq 0 2);do chanid=$(ls -l /sys/class/net/%1/device/cdev$i);echo ${chanid##*/};done|tr '\n' ' '", device));
  if (size(chan_ids["stdout"]:"")>0) chanids=String::CutBlanks(chan_ids["stdout"]:"");
  map <string, any> port_name=(map<string, any>)SCR::Execute(.target.bash_output, sformat("cat /sys/class/net/%1/device/portname|tr -d '\n'", device));
  if (size(port_name["stdout"]:"")>0) portname=String::CutBlanks(port_name["stdout"]:"");
  map <string, any> proto=(map<string, any>)SCR::Execute(.target.bash_output, sformat("cat /sys/class/net/%1/device/protocol|tr -d '\n'", device));
  if (size(proto["stdout"]:"")>0) protocol=String::CutBlanks(proto["stdout"]:"");
  boolean layer2 = ((integer)SCR::Execute(.target.bash, sformat("grep -q 1 /sys/class/net/%1/device/layer2", device))==0) ? true : false;

   AY["s390-devices", device]=$["type":device_type];
   if (size(chanids)>0) AY["s390-devices", device, "chanids"]=chanids;
//   if (size(portname)>0) AY[device, "portname"]=portname;
   if (size(protocol)>0) AY["s390-devices", device, "protocol"]=protocol;
   if (layer2) AY["s390-devices", device, "layer2"]=true;

   map<string, any> port0 = (map<string, any>)SCR::Execute(.target.bash_output, sformat("port0=$(ls -l /sys/class/net/%1/device/cdev0);echo ${port0##*/}|tr -d '\n'", device));
y2internal("port0 %1", port0);
   if (size(port0["stdout"]:"")>0){
    string value = port0["stdout"]:"";
    AY["net-udev", device]=$["rule"  : "KERNELS",
			     "name"  : device,
			     "value" : value
			    ];
   }
  });
 } else{
  foreach(integer id, map<string, any> row, (map<integer, map <string, any> >)LanItems::Items, {
   LanItems::current=id;
   if (size(row["ifcfg"]:"")>0){
    string name	    = LanItems::GetItemUdev("NAME");
    string mac_rule = LanItems::GetItemUdev("ATTR{address}");
    string bus_rule = LanItems::GetItemUdev("KERNELS");
    if (size(mac_rule)==0 && size(bus_rule)==0){
     y2error("No MAC or BusID rule %1", row);
     continue;
    }
    AY["net-udev", name]=$["rule"  : size(mac_rule)>0 ? "ATTR{address}" : "KERNELS",
                           "name"  : name,
                           "value" : size(mac_rule)>0 ? mac_rule : bus_rule
                          ];

   }
  });
 }

 y2internal("AY profile %1", AY);
 return AY;
}

global string GetDevnameByMAC(string mac){
 string devname="";
 if (size(mac)>0){
  foreach(integer id, map<string, any> row, (map<integer, map <string, any> >)LanItems::Items, {
   LanItems::current=id;
    string name	    = LanItems::GetItemUdev("NAME");
    string mac_rule = LanItems::GetItemUdev("ATTR{address}");
    if (size(mac_rule)==0){
     y2error("No MAC rule %1", row);
     continue;
    } else
	y2internal("MAC rule %1", row);
    if (mac_rule==mac){
	devname=name;
     y2internal("Rule matched! New devname %1", devname);
     break;
    }
  });

 } else y2warning("No MAC address to compare.");
 return devname;
}



}
