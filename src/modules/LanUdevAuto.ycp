/**
 * File:        modules/LanUdevAuto.ycp
 * Package:     Network configuration
 * Summary:     Udev rules for autoinstallation
 * Authors:     Michal Zugec <mzugec@suse.cz>
 *
 * $Id: Lan.ycp 40537 2007-08-28 13:22:01Z mzugec $
 *
 * Representation of the configuration of network cards.
 */

{
 module     "LanUdevAuto";
 import "LanItems";
 import "Map";
 include "network/routines.ycp";

 textdomain "network";

 list<map> udev_rules=[];
 list<map> s390_devices=[];
 list <map> hardware=nil;

/**
 * @return parameter from /etc/install.inf or nil
 * @param name parameter name, case sensitive
 */
string InstallInfParameter(string name) {
    path p = add(.etc.install_inf, name);
    return (string) SCR::Read(p);
}

/**
 * @return parameter from the kernel(boot) command line or nil
 * @param name parameter name, case sensitive
 */
string KernelCmdlineParameter(string name) {
    string cmdline = InstallInfParameter("Cmdline");
    map cmdmap = Map::FromString(cmdline); // handles nil too
    return (string) cmdmap[name]:nil;
}

/**
 * @return installation parameter or nil
 * @param name parameter name, case sensitive
 */
string InstallationParameter(string name) {
    string value = InstallInfParameter(name);
    if (value == nil) {
        value = KernelCmdlineParameter(name);
    }
    return value;
}

// FATE#311332
global boolean AllowUdevModify() {
    return InstallationParameter("biosdevname") != "1";
}

global string getDeviceName(string oldname){
 string newname=oldname;
 if (hardware==nil) hardware=ReadHardware("netcard");

   if (issubstring(oldname, "-id-")){
    y2milestone("device by ID found %1", oldname);

   string mac_from_ay = splitstring(tostring(oldname), "-")[2]:"";
    y2milestone("MAC address from AY : %1", mac_from_ay);
    foreach(map hw, hardware, {
     y2internal("hw %1", hw["mac"]:"");
     if (hw["mac"]:""==mac_from_ay){
      y2milestone("device matched : %1", hw["dev_name"]:"");
      newname = hw["dev_name"]:"";
     }
    });
   }

   else if (issubstring(oldname, "-bus-")){
    y2milestone("device by BUS found %1", oldname);
    string bus_from_ay = splitstring(tostring(oldname), "-")[2]:"";
    y2milestone("BUSID from AY : %1", bus_from_ay);
    foreach(map hw, hardware, {
     y2internal("hw %1", hw["busid"]:"");
     if (hw["busid"]:""==bus_from_ay){
      y2milestone("device matched : %1", hw["dev_name"]:"");
      newname = hw["dev_name"]:"";
     }
    });
   }
 if (oldname==newname) y2milestone("nothing changed, %1 is old style dev_name", newname);
 return newname;
}

/**
 *  internal function:
 *  check if old-style (ifcfg-eth-id-..., ifcfg-eth-bus-... is used) or new-style (ifcfg-eth0)
 */
 boolean oldStyle(map ay){
  boolean old_style_found = false;
  foreach(map interface, ay["interfaces"]:[], {
   if (issubstring(interface["device"]:"", "-id-")) old_style_found=true;
   if (issubstring(interface["device"]:"", "-bus-")) old_style_found=true;
  });
  y2milestone("old-style found:%1", old_style_found);
  return old_style_found;
 }

/**
 *  internal function:
 *  for old-slyle create udev rules and rename interface names to new-style
 */
 list<map> createUdevFromIfaceName(list<map> interfaces){
  y2milestone("old-style names for interfaces found - convert into new-style");
  y2internal("interfaces %1", interfaces);
  list<map> tmp_interfaces=[];
  foreach(map interface, interfaces, {
   if (issubstring(interface["device"]:"", "-id-")||issubstring(interface["device"]:"", "-bus-")){
    string value = splitstring(interface["device"]:"", "-")[2]:"";
    string rule="ATTR{address}";
    if (splitstring(interface["device"]:"", "-")[1]:"" == "bus") rule = "KERNELS";
    udev_rules = add(udev_rules,
				$[
				  "rule"  : rule,
				  "value" : value,
				  "name"  : getDeviceName( interface["device"]:"" )
				 ]);
    tmp_interfaces=add(tmp_interfaces, interface);
   }
  });
  y2milestone("converted interfaces: %1", tmp_interfaces);
  return tmp_interfaces;
 }

 global define boolean Import(map settings) {
y2milestone("importing %1", settings);
  if (oldStyle(settings)) settings["interfaces"] = createUdevFromIfaceName(settings["interfaces"]:[]);
	else udev_rules = settings["net-udev"]:[];
/*  if (Arch::s390())*/ s390_devices=settings["s390-devices"]:[];
  y2milestone("interfaces: %1", settings["interfaces"]:[]);
  y2milestone("net-udev rules:%1", udev_rules);
  y2milestone("s390-devices rules:%1", s390_devices);
  return true;
 }

 global define boolean Write(){
 list<string> comment = ["# Generated by autoyast",
			"# program run by the persistent-net-generator.rules rules file.",
			"#",
			"# You can modify it, as long as you keep each rule on a single line." ];
  list<string> rules = [];
  foreach(map rule, udev_rules, {
   rules = add(rules, sformat("SUBSYSTEM==\"net\", ACTION==\"add\", DRIVERS==\"?*\", %1==\"%2\", NAME=\"%3\"",
						rule["rule"]:"", rule["value"]:"", rule["name"]:""));
  });
  if (size(rules)>0){
   y2milestone("Writing AY udev rules for network (will replace original rules from 1st stage)");
    y2milestone("rules: %1", rules);
   if (AllowUdevModify()){
    SCR::Write(.udev_persistent.rules_comment, comment);
    SCR::Write(.udev_persistent.rules, rules);
    SCR::Write(.udev_persistent.nil, []);
   }
  } else
     y2milestone("No udev rules defined by AY, nothing to write (keep original file)");
  if (Arch::s390()){
   foreach(map rule, s390_devices, {
    LanItems::Select("");
    LanItems::type=rule["type"]:"";
    LanItems::qeth_chanids=rule["chanids"]:"";
    LanItems::qeth_layer2 = rule["layer2"]:false;
//    LanItems::qeth_portnumber = rule["portnumber"]:"";
    LanItems::qeth_portname=rule["portname"]:"";
    LanItems::chan_mode=rule["protocol"]:"";
    LanItems::iucv_user=rule["router"]:"";

    y2milestone("rule:%1", rule);
    y2milestone("type:%1", LanItems::type);
    y2milestone("chanids:%1", LanItems::qeth_chanids);
    y2milestone("layer2:%1", LanItems::qeth_layer2);
    y2milestone("portname:%1", LanItems::qeth_portname);
//    y2milestone("portnumber:%1", LanItems::qeth_portnumber);
    LanItems::createS390Device();
    y2internal("rule %1", rule);
   });
   y2internal("Writing s390 rules %1", s390_devices);
  }
  return true;
 }

global map Export(map devices){
 map AY=$["s390-devices":$[], "net-udev":$[]];
 if (Arch::s390()){
  list<string> devs=[];
  foreach(string type, any value, (map<string, any>)devices, {
   devs = (list<string>)union((list)devs, Map::Keys((map)value));
  });
  foreach(string device, devs, {
   map<string, any> driver=(map<string, any>)SCR::Execute(.target.bash_output, sformat("driver=$(ls -l /sys/class/net/%1/device/driver);echo ${driver##*/}|tr -d '\n'", device));
   string device_type="";
   string chanids="";
   string portname="";
   string protocol="";
   if(driver["exit"]:-1==0){
    switch(driver["stdout"]:""){
     case "qeth":
	device_type=driver["stdout"]:"";
	break;
     case "ctcm":
	device_type="ctc";
	break;
     case "netiucv":
	device_type="iucv";
	break;
     default:
	y2error("unknown driver type :%1", driver["stdout"]:"");
    }
   } else{
    y2error("%1", driver);
    continue;
   }
  map <string, any> chan_ids=(map<string, any>)SCR::Execute(.target.bash_output,
		sformat("for i in $(seq 0 2);do chanid=$(ls -l /sys/class/net/%1/device/cdev$i);echo ${chanid##*/};done|tr '\n' ' '", device));
  if (size(chan_ids["stdout"]:"")>0) chanids=String::CutBlanks(chan_ids["stdout"]:"");
  map <string, any> port_name=(map<string, any>)SCR::Execute(.target.bash_output, sformat("cat /sys/class/net/%1/device/portname|tr -d '\n'", device));
  if (size(port_name["stdout"]:"")>0) portname=String::CutBlanks(port_name["stdout"]:"");
  map <string, any> proto=(map<string, any>)SCR::Execute(.target.bash_output, sformat("cat /sys/class/net/%1/device/protocol|tr -d '\n'", device));
  if (size(proto["stdout"]:"")>0) protocol=String::CutBlanks(proto["stdout"]:"");
  boolean layer2 = ((integer)SCR::Execute(.target.bash, sformat("grep -q 1 /sys/class/net/%1/device/layer2", device))==0) ? true : false;

   AY["s390-devices", device]=$["type":device_type];
   if (size(chanids)>0) AY["s390-devices", device, "chanids"]=chanids;
   if (size(portname)>0) AY["s390-devices",device, "portname"]=portname;
   if (size(protocol)>0) AY["s390-devices", device, "protocol"]=protocol;
   if (layer2) AY["s390-devices", device, "layer2"]=true;

   map<string, any> port0 = (map<string, any>)SCR::Execute(.target.bash_output, sformat("port0=$(ls -l /sys/class/net/%1/device/cdev0);echo ${port0##*/}|tr -d '\n'", device));
y2internal("port0 %1", port0);
   if (size(port0["stdout"]:"")>0){
    string value = port0["stdout"]:"";
    AY["net-udev", device]=$["rule"  : "KERNELS",
			     "name"  : device,
			     "value" : value
			    ];
   }
  });
 } else{
  foreach(integer id, map<string, any> row, (map<integer, map <string, any> >)LanItems::Items, {
   LanItems::current=id;
   if (size(row["ifcfg"]:"")>0){
    string name	    = LanItems::GetItemUdev("NAME");
    string mac_rule = LanItems::GetItemUdev("ATTR{address}");
    string bus_rule = LanItems::GetItemUdev("KERNELS");
    if (size(mac_rule)==0 && size(bus_rule)==0){
     y2error("No MAC or BusID rule %1", row);
     continue;
    }
    AY["net-udev", name]=$["rule"  : size(mac_rule)>0 ? "ATTR{address}" : "KERNELS",
                           "name"  : name,
                           "value" : size(mac_rule)>0 ? mac_rule : bus_rule
                          ];

   }
  });
 }

 y2internal("AY profile %1", AY);
 return AY;
}

global string GetDevnameByMAC(string mac){
 string devname="";
 if (size(mac)>0){
  y2milestone("MAC address from 1st stage: %1", mac);
  foreach(map rule, udev_rules, {
   if (rule["rule"]:""=="ATTR{address}"){
     if (mac==rule["value"]:""){
       devname=rule["name"]:"";
       y2milestone("MAC address matched with device:%1", rule["name"]:"");
       break;
     }
   } else if (rule["rule"]:""=="KERNELS"){
	y2milestone("rule: %1", rule);
	map cmd = (map)SCR::Execute(.target.bash_output,
	sformat( "DEVICE=$(grep '%1' /sys/class/net/*/address);KERNELS=$(ls -l \"$(echo ${DEVICE%%/*})/device\");echo ${KERNELS##*/}|tr -d '\n'", mac));
	if (cmd["exit"]:-1==0){
	  y2milestone("cmd output:%1", cmd["stdout"]:"");
          if (cmd["stdout"]:""==rule["value"]:""){
	    y2internal("match!");
	    devname=rule["name"]:"";
          }
        }
   } else
	y2error("Unknown rule for:%1", rule);
  });
 } else y2warning("No MAC address to compare.");
 return devname;
}



}
